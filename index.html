<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Caixa de Miraculos</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Pacifico&display=swap');

    body {
      font-family: 'Rockwell', serif;
      margin: 0;
      padding: 0;
      background: url('https://i.imgur.com/your-background-image.jpg') no-repeat center center fixed;
      background-size: cover;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    .container {
      background-color: rgba(0, 0, 0, 0.7);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      width: 90%;
      max-width: 600px;
      text-align: center;
      position: relative;
    }

    h1 {
      font-size: 3em;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
      margin-bottom: 20px;
      font-family: 'Pacifico', cursive;
    }

    .hero-buttons {
      margin-top: 20px;
    }

    .hero-buttons hr {
      border: none;
      border-top: 2px solid #00ffff;
      margin: 20px 0;
    }

    .hero-buttons button {
      background-color: #ff007f;
      color: #fff;
      border: none;
      padding: 15px 30px;
      font-size: 1.2em;
      font-family: 'Rockwell', serif;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(255, 0, 127, 0.4);
      width: 100%;
      margin-bottom: 10px;
    }

    .hero-buttons button:hover {
      background-color: #ff3399;
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(255, 0, 127, 0.6);
    }

    .hero-buttons p {
      margin-top: 5px;
      font-size: 1.1em;
      color: #eee;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    }

    /* Estilos base para todas as interfaces (chat e poderes) */
    .hero-interface, .power-interface {
      display: none; /* Hidden by default */
      background-color: rgba(0, 0, 0, 0.85);
      padding: 25px;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 0 15px rgba(255, 255, 0, 0.7);
      animation: fadeIn 0.5s ease-in-out;
      flex-direction: column;
      height: 450px;
      box-sizing: border-box; /* Incluir padding na altura/largura */
    }

    /* Estilo espec√≠fico para interfaces de poder que podem ser menus */
    .power-interface {
      height: auto; /* Altura flex√≠vel para menus */
      min-height: 200px;
      justify-content: center;
      align-items: center;
      gap: 15px;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .hero-interface h2, .power-interface h2 {
      color: #ffd700;
      font-size: 2em;
      margin-bottom: 15px;
    }

    /* Estilos de chat */
    .chat-display {
      flex-grow: 1;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      padding: 10px;
      margin-bottom: 15px;
      overflow-y: auto;
      text-align: left;
      font-size: 0.95em;
      line-height: 1.4;
      color: #e0e0e0;
      box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
    }

    .chat-message {
      margin-bottom: 8px;
    }

    .chat-message strong {
      color: #00ffff;
    }

    .chat-input-area {
      display: flex;
      gap: 10px;
      margin-top: auto;
    }

    .chat-input-area input[type="text"] {
      flex-grow: 1;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #00ffff;
      background-color: rgba(255, 255, 255, 0.15);
      color: #fff;
      font-family: 'Rockwell', serif;
      font-size: 1em;
    }

    .chat-input-area input[type="text"]::placeholder {
      color: #bbb;
    }

    .chat-input-area button {
      background-color: #008080;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.3s ease;
      font-family: 'Rockwell', serif;
    }

    .chat-input-area button:hover {
      background-color: #006666;
    }

    .close-button {
      background-color: #dc3545;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.3s ease;
      margin-top: 15px;
    }

    .close-button:hover {
      background-color: #c82333;
    }

    /* Estilos para bot√µes de poder dentro das interfaces */
    .power-interface button {
      background-color: #8A2BE2; /* Azul violeta */
      color: white;
      border: none;
      padding: 12px 25px;
      font-size: 1.1em;
      font-family: 'Rockwell', serif;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4);
      width: 80%; /* Ajuste a largura conforme necess√°rio */
      max-width: 300px;
      margin-bottom: 10px;
    }

    .power-interface button:hover {
      background-color: #9370DB; /* Roxa m√©dia */
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(138, 43, 226, 0.6);
    }

    .power-info {
      color: #e0e0e0;
      font-size: 0.9em;
      margin-bottom: 10px;
      line-height: 1.4;
      max-width: 90%;
    }

    .akuma-chat-area {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      gap: 10px;
    }

    .akuma-chat-area .chat-display {
      flex-grow: 1;
      height: 150px; /* Altura fixa para o chat do Akumatizado */
      min-height: 100px;
    }

    .akuma-control button {
      background-color: #ff4500; /* Laranja avermelhado */
      margin-right: 10px;
      margin-bottom: 10px;
    }
    .akuma-control button:hover {
      background-color: #cc3700;
    }

    /* Estilos para o timer de destransforma√ß√£o */
    .timer-display {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(255, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 1em;
      font-weight: bold;
      z-index: 100;
      display: none; /* Oculto por padr√£o */
    }

    /* Estilos adicionais para efeitos de chat */
    .abrax-inverted-chat-effect {
      transform: scaleX(-1);
      direction: rtl;
      unicode-bidi: bidi-override;
    }

    .akumatized-message-style {
      color: #ff0000;
      font-style: italic;
      text-decoration: wavy underline;
    }
  </style>
</head>
<body>
  <div class="container">
    <center>
      <h1>‚Ä¢¬∞‚Ä¢Aurore Boreale¬∞‚Ä¢¬∞‚Ä¢</h1>
    </center>

    <div class="hero-buttons" id="heroButtons">
      <hr>
      <button onclick="litlegot()">Litlegot üñåÔ∏è</button>
      <p>Regras s√£o pura op√ß√£o, Eu escolho como devo pintar</p>
      <hr>
      <button onclick="abrax()">Abrax ü™∂</button>
      <p>Eu sou o √∫nico que pode Definir o Ponto final</p>
      <hr>
      <button onclick="psique()">Psique ü¶ã</button>
      <p>Entre a vida e a morte, Eu sou o Destino</p>
      <hr>
      <button onclick="yellowfer()">Yellowfer ‚è≥</button>
      <p>N√£o existe verdade Absoluta, a hist√≥ria sempre tem 2 lados</p>
      <hr>
      <button onclick="lindenbergue()">Lindenbergue ü™û</button>
      <p>Do pode ser vida?, Se o mundo √© desconhecido</p>
      <hr>
      <button onclick="beast()">Beast ‚öîÔ∏è</button>
      <p>O verdadeiro monstro, √â aquele se torna nosso aliado</p>
      <hr>
    </div>

    <div id="destransformTimer" class="timer-display"></div>

    <div id="globalChatDisplay" class="chat-display" style="display: none; margin-top: 20px;"></div>

    <div id="litlegotInterface" class="hero-interface">
      <h2>Litlegot üñåÔ∏è</h2>
      <div class="chat-input-area">
        <input type="text" id="chatInput_litlegot" placeholder="Digite sua mensagem ou comando de poder (/genesis)...">
        <button onclick="sendMessage('Litlegot', 'litlegot')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('litlegotInterface')">Sair do Chat</button>
    </div>

    <div id="abraxInterface" class="hero-interface">
      <h2>Abrax ü™∂</h2>
      <div class="chat-input-area">
        <input type="text" id="chatInput_abrax" placeholder="Digite sua mensagem ou comando de poder (/sublimacao)...">
        <button onclick="sendMessage('Abrax', 'abrax')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('abraxInterface')">Sair do Chat</button>
    </div>

    <div id="psiqueInterface" class="hero-interface">
      <h2>Psique ü¶ã</h2>
      <div class="akuma-chat-area">
        <h3>Comunica√ß√£o com Akumatizado: <span id="akumatizedNameDisplay">Ningu√©m</span></h3>
        <div class="chat-display" id="akumaChatDisplay"></div>
        <div class="chat-input-area">
          <input type="text" id="akumaChatInput" placeholder="Fale com o Akumatizado...">
          <button onclick="sendAkumaMessage('Psique')">Enviar</button>
        </div>
        <div class="akuma-control">
          <button onclick="promptAkumaName()">Akumatizar</button>
          <button onclick="desakumatizar()">Desakumatizar</button>
        </div>
      </div>
      <div class="chat-input-area">
        <input type="text" id="chatInput_psique" placeholder="Digite sua mensagem ou comando de poder (/akumatizacao)...">
        <button onclick="sendMessage('Psique', 'psique')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('psiqueInterface')">Sair do Chat</button>
    </div>

    <div id="yellowferInterface" class="hero-interface">
      <h2>Yellowfer ‚è≥</h2>
      <div class="chat-input-area">
        <input type="text" id="chatInput_yellowfer" placeholder="Digite sua mensagem ou comando de poder (/segundachance)...">
        <button onclick="sendMessage('Yellowfer', 'yellowfer')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('yellowferInterface')">Sair do Chat</button>
    </div>

    <div id="lindenbergueInterface" class="hero-interface">
      <h2>Lindenbergue ü™û</h2>
      <div class="chat-input-area">
        <input type="text" id="chatInput_lindenbergue" placeholder="Digite sua mensagem ou comando de poder (/viajar)...">
        <button onclick="sendMessage('Lindenbergue', 'lindenbergue')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('lindenbergueInterface')">Sair do Chat</button>
    </div>

    <div id="beastInterface" class="hero-interface">
      <h2>Beast ‚öîÔ∏è</h2>
      <div class="chat-input-area">
        <input type="text" id="chatInput_beast" placeholder="Digite sua mensagem ou comando de poder (/dragao)...">
        <button onclick="sendMessage('Beast', 'beast')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('beastInterface')">Sair do Chat</button>
    </div>

    <div id="litlegotGenesisInterface" class="power-interface">
        <h2>G√™nesis üñåÔ∏è</h2>
        <p class="power-info">Crie qualquer objeto (tecnol√≥gico ou n√£o). Limite: n√£o pode criar magia.</p>
        <input type="text" id="genesisObjectInput" placeholder="O que deseja criar?">
        <button onclick="activateGenesis()">Criar Objeto</button>
        <p id="genesisOutput" class="power-info"></p>
        <button class="close-button" onclick="closePowerInterface('litlegotGenesisInterface')">Voltar ao Chat</button>
    </div>

    <div id="abraxSublimacaoInterface" class="power-interface">
        <h2>Sublima√ß√£o ü™∂</h2>
        <p class="power-info">Concede a si mesmo qualquer poder. Limites: n√£o pode interferir na magia de Miraculous/Kwamis, nem copiar poderes de outros Kwamis (apenas semelhantes).</p>
        <input type="text" id="sublimacaoPowerInput" placeholder="Qual poder deseja conceder a si mesmo?">
        <button onclick="activateSublimacao()">Conceder Poder</button>
        <p id="sublimacaoOutput" class="power-info"></p>
        <button class="close-button" onclick="closePowerInterface('abraxSublimacaoInterface')">Voltar ao Chat</button>
    </div>

    <div id="yellowferSecondChanceInterface" class="power-interface">
        <h2>Segunda Chance ‚è≥</h2>
        <p class="power-info">Volte 5 minutos no tempo de forma indefinida. Limites: Apenas pode voltar para o momento que ativou o poder. Se 5 minutos acabam e voc√™ n√£o volta, o efeito finaliza e destransforma.</p>
        <button onclick="activateSecondChance()">Ativar Segunda Chance</button>
        <p id="secondChanceStatus" class="power-info"></p>
        <button class="close-button" onclick="closePowerInterface('yellowferSecondChanceInterface')">Voltar ao Chat</button>
    </div>

    <div id="lindenbergueViajarInterface" class="power-interface">
        <h2>Viajar ü™û</h2>
        <p class="power-info">Abre um portal para qualquer lugar. Limite: Apenas um portal por vez.</p>
        <input type="text" id="portalDestinationInput" placeholder="Para onde deseja ir?">
        <button onclick="activateViajar()">Abrir Portal</button>
        <p id="portalStatus" class="power-info"></p>
        <button class="close-button" onclick="closePowerInterface('lindenbergueViajarInterface')">Voltar ao Chat</button>
    </div>

    <div id="beastDragaoInterface" class="power-interface">
        <h2>Drag√£o de Elemento ‚öîÔ∏è</h2>
        <p class="power-info">Controle 3 elementos. Limite: Um elemento por vez. Usar os 3 inicia o timer de 5 min para destransformar.</p>
        <p class="power-info">Elementos: Fogo, √Ågua, Vento, Terra (ex: /dragao fogo)</p>
        <input type="text" id="dragonElementInput" placeholder="Qual elemento deseja controlar? (Ex: fogo)">
        <button onclick="activateDragao()">Controlar Elemento</button>
        <p id="dragonStatus" class="power-info"></p>
        <button class="close-button" onclick="closePowerInterface('beastDragaoInterface')">Voltar ao Chat</button>
    </div>
  </div> <script type="module">
  // Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-analytics.js";
  import { getDatabase, ref, onValue, push, set, update, remove, get } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";
    
  // Your web app's Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyBONdrMeMEhigQ1SEhJMrkEeArf5xfF8YA",
    authDomain: "miraculos-276b1.firebaseapp.com",
    projectId: "miraculos-276b1",
    storageBucket: "miraculos-276b1.firebasestorage.app",
    messagingSenderId: "643841644582",
    appId: "1:643841644582:web:b0eba5d722d55aea83eee7",
    measurementId: "G-FGYS755H2B"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const database = getDatabase(app);
  const analytics = getAnalytics(app);
    
  // Firebase References (updated to use ref() for v9+)
  const globalChatRef = ref(database, 'globalChatMessages');
  const powerUsedRef = ref(database, 'powerUsedState');
  const heroTransformEndTimesRef = ref(database, 'heroTransformEndTimes');
  const heroEvolvedRef = ref(database, 'heroEvolved');
  const akumaStateRef = ref(database, 'akumaState');
  const yellowferSecondChanceTimeRef = ref(database, 'yellowferSecondChanceTime');
  const yellowferSecondChanceActiveRef = ref(database, 'yellowferSecondChanceActive');
  const beastControlledElementsRef = ref(database, 'beastControlledElements');
  const chatBlockedStateRef = ref(database, 'chatBlockedState');
  const chatRedirectStateRef = ref(database, 'chatRedirectState');
  const akumatizedEffectOnChatRef = ref(database, 'akumatizedEffectOnChat');
  const litlegotCreatedItemRef = ref(database, 'litlegotCreatedItem');
  const abraxSelfGrantedPowerRef = ref(database, 'abraxSelfGrantedPower');
  const invertedChatStateRef = ref(database, 'invertedChatState');
  const akumaChatRef = ref(database, 'akumaChatMessages');
  const abraxPuppetStringsStateRef = ref(database, 'abraxPuppetStringsState');
  const psiqueGrantedPowerRef = ref(database, 'psiqueGrantedPower');

  // Variables for Realtime Sync (will be updated by Firebase listeners)
  let powerUsedState = {};
  let transformEndTimes = {};
  let evolvedHeroes = {};
  let akumaState = { name: "", akumaChat: [], power: "", privateChatActive: false };
  let yellowferSecondChanceActive = false;
  let yellowferSecondChanceTimestamp = null;
  let beastControlledElements = [];
  let chatBlockedState = {};
  let chatRedirectState = { active: false, fromHero: '', toHero: '' };
  let akumatizedEffectOnChat = { active: false, name: '', distortedMessages: false };
  let litlegotCreatedItem = null;
  let abraxSelfGrantedPower = null;
  let invertedChatState = { active: false, targetHero: '' };
  let abraxPuppetStringsState = { active: false, targetHero: '', messagesLeft: 0 };
  let psiqueGrantedPower = { active: false, targetHero: '', grantedPowerType: '', usesRemaining: 0, granter: '' };


  // Local UI state variables (not synced via Firebase)
  let destransformIntervalId = null;
  let currentActiveHero = null;
  let globalChatMessages = []; // Local cache for global messages
  let akumaChatMessages = []; // Local cache for akuma messages

  const FIVE_MINUTES_MS = 5 * 60 * 1000;
  const HERO_NAMES = ['Litlegot', 'Abrax', 'Psique', 'Yellowfer', 'Lindenbergue', 'Beast'];
  const ABRAX_PREDEFINED_POWERS = [
    'inversao', 'oraculo', 'cordas de fantoche', 'mimetismo', 'aura de cura',
    'escudo psiquico', 'projecao astral', 'teletransporte menor', 'ilusao', 'catalise'
  ];
  const PSIQUE_CONCEDE_POWERS = [
    'poder_ilimitado', 'criar_item', 'reverter_tempo', 'silenciar_beast' // Renamed 'silenciar' to avoid conflict and specify target
  ];


  // --- Firebase Data Listeners ---
  function setupFirebaseListeners() {
    onValue(globalChatRef, (snapshot) => {
      // Firebase stores lists as objects with unique keys, convert to array for easier processing
      globalChatMessages = [];
      snapshot.forEach((childSnapshot) => {
        globalChatMessages.push({ key: childSnapshot.key, ...childSnapshot.val() });
      });
      renderGlobalChat();
    });

    onValue(akumaChatRef, (snapshot) => {
      akumaChatMessages = [];
      snapshot.forEach((childSnapshot) => {
        akumaChatMessages.push({ key: childSnapshot.key, ...childSnapshot.val() });
      });
      renderAkumaChat();
    });

    onValue(powerUsedRef, (snapshot) => {
      powerUsedState = snapshot.val() || {};
    });

    onValue(heroTransformEndTimesRef, (snapshot) => {
      transformEndTimes = snapshot.val() || {};
      if (currentActiveHero && transformEndTimes[currentActiveHero] && !evolvedHeroes[currentActiveHero]) {
        updateDestransformTimerDisplay(currentActiveHero, transformEndTimes[currentActiveHero]);
      } else if (currentActiveHero && evolvedHeroes[currentActiveHero]) {
        hideDestransformTimer();
      }
    });

    onValue(heroEvolvedRef, (snapshot) => {
      evolvedHeroes = snapshot.val() || {};
      if (currentActiveHero && evolvedHeroes[currentActiveHero]) {
        hideDestransformTimer();
        if (transformTimers[currentActiveHero]) {
          clearTimeout(transformTimers[currentActiveHero]);
          delete transformTimers[currentActiveHero];
          remove(ref(database, `heroTransformEndTimes/${currentActiveHero}`));
        }
      }
    });

    onValue(akumaStateRef, (snapshot) => {
      akumaState = snapshot.val() || { name: "", akumaChat: [], power: "", privateChatActive: false };
      updateAkumaDisplay();
      const akumaChatArea = document.querySelector('.akuma-chat-area');
      if (akumaState.name && akumaState.privateChatActive && akumaChatArea) {
        akumaChatArea.classList.add('akumatized-chat-effect');
      } else if (akumaChatArea) {
        akumaChatArea.classList.remove('akumatized-chat-effect');
      }
    });

    onValue(yellowferSecondChanceTimeRef, (snapshot) => {
      yellowferSecondChanceTimestamp = snapshot.val();
  if (yellowferSecondChanceTimestamp) {
        document.getElementById('secondChanceStatus').innerText = `Segunda Chance Ativada! Ponto de retorno: ${new Date(yellowferSecondChanceTimestamp).toLocaleTimeString()}`;
      } else {
        document.getElementById('secondChanceStatus').innerText = '';
      }
    });

    onValue(yellowferSecondChanceActiveRef, (snapshot) => {
      yellowferSecondChanceActive = snapshot.val() || false;
    });

    onValue(beastControlledElementsRef, (snapshot) => {
      beastControlledElements = snapshot.val() || [];
    });

    onValue(chatBlockedStateRef, (snapshot) => {
      chatBlockedState = snapshot.val() || {};
      renderGlobalChat();
    });

    onValue(chatRedirectStateRef, (snapshot) => {
      chatRedirectState = snapshot.val() || { active: false, fromHero: '', toHero: '' };
    });

    onValue(akumatizedEffectOnChatRef, (snapshot) => {
      akumatizedEffectOnChat = snapshot.val() || { active: false, name: '', distortedMessages: false };
      renderGlobalChat();
    });

    onValue(litlegotCreatedItemRef, (snapshot) => {
      litlegotCreatedItem = snapshot.val();
      const genesisOutput = document.getElementById('genesisOutput');
      if (genesisOutput) {
        genesisOutput.innerText = litlegotCreatedItem ? `Item criado: "${litlegotCreatedItem}"` : '';
      }
    });

    onValue(abraxSelfGrantedPowerRef, (snapshot) => {
      abraxSelfGrantedPower = snapshot.val();
      const sublimacaoOutput = document.getElementById('sublimacaoOutput');
      if (sublimacaoOutput) {
        sublimacaoOutput.innerText = abraxSelfGrantedPower ? `Poder concedido: "${abraxSelfGrantedPower}"` : '';
      }
    });

    onValue(invertedChatStateRef, (snapshot) => {
      invertedChatState = snapshot.val() || { active: false, targetHero: '' };
      renderGlobalChat();
    });

    onValue(abraxPuppetStringsStateRef, (snapshot) => {
      abraxPuppetStringsState = snapshot.val() || { active: false, targetHero: '', messagesLeft: 0 };
    });

    onValue(psiqueGrantedPowerRef, (snapshot) => {
      psiqueGrantedPower = snapshot.val() || { active: false, targetHero: '', grantedPowerType: '', usesRemaining: 0, granter: '' };
    });
  }
    
  // Call listeners on load
  setupFirebaseListeners();

  // Load last active hero state from localStorage if available
  document.addEventListener('DOMContentLoaded', () => {
    const lastActiveHeroOnLoad = localStorage.getItem('lastActiveHero');
    const storedEndTimes = JSON.parse(localStorage.getItem('heroTransformEndTimes') || '{}'); // Retrieve stored end times

    // Only activate if there's a last active hero and no power_ilimitado
    if (
      lastActiveHeroOnLoad &&
      storedEndTimes[lastActiveHeroOnLoad] &&
      !(psiqueGrantedPower.active &&
        psiqueGrantedPower.targetHero === lastActiveHeroOnLoad &&
        psiqueGrantedPower.grantedPowerType === 'poder_ilimitado')
    ) {
      currentActiveHero = lastActiveHeroOnLoad;
      // Re-initialize the timer display based on stored end time
      updateDestransformTimerDisplay(lastActiveHeroOnLoad, storedEndTimes[lastActiveHeroOnLoad]);
      // Show the interface if a hero was active, otherwise hide the timer
      const lastInterfaceId = `${lastActiveHeroOnLoad.toLowerCase()}Interface`;
      const interfaceElement = document.getElementById(lastInterfaceId);
      if (interfaceElement) {
        document.querySelectorAll('.hero-interface, .power-interface').forEach(el => el.style.display = 'none');
        document.getElementById('heroButtons').style.display = 'none';
        interfaceElement.style.display = 'flex';
      } else {
         hideDestransformTimer();
         document.getElementById('heroButtons').style.display = 'block';
      }
    } else {
       // If no active hero or unlimited power, ensure buttons are visible and timer is hidden
       document.getElementById('heroButtons').style.display = 'block';
       hideDestransformTimer();
    }

    renderGlobalChat();
    updateAkumaDisplay();
    renderAkumaChat();
  });


  // --- Hero transformation functions ---
  function litlegot() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'inspira√ß√£o') {
      alert("Ziggy! Inspira√ß√£o!");
      showInterface('litlegotInterface', 'Litlegot');
    } else if (transforma !== null) {
      alert("Diga a Ziggy Sua frase De transforma√ß√£o");
    } else {
      alert('Ordem Nula!');
    }
  }

  function abrax() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'sol nascente') {
      alert("Orikko! Sol Nascente!");
      showInterface('abraxInterface', 'Abrax');
    } else if (transforma !== null) {
      alert("Diga ao Orikko Sua frase de transforma√ß√£o!");
    } else {
      alert('Ordem Nula!');
    }
  }

  function psique() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'irradia√ß√£o') {
      alert("Nooroo! Irradiar!");
      showInterface('psiqueInterface', 'Psique');
    } else if (transforma !== null) {
      alert("Diga ao Nooroo Sua frase de transforma√ß√£o!");
    } else {
      alert('Ordem Nula!');
    }
  }

  function yellowfer() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'restaurar') {
      alert("Sazz! Restaura√ß√£o!");
      showInterface('yellowferInterface', 'Yellowfer');
    } else if (transforma !== null) {
      alert("Diga ao Sazz Sua frase de transforma√ß√£o!");
    } else {
      alert('Ordem Nula!');
    }
  }

  function lindenbergue() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'avan√ßar') {
      alert("Kaalki! Avan√ßar!");
      showInterface('lindenbergueInterface', 'Lindenbergue');
    } else if (transforma !== null) {
      alert("Diga a Kaalki Sua frase de transforma√ß√£o!");
    } else {
      alert('Ordem Nula!');
    }
  }

  function beast() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'exatid√£o') {
      alert("Loong! Exatid√£o!");
      showInterface('beastInterface', 'Beast');
    } else if (transforma !== null) {
      alert("Diga ao Loong Sua frase de transforma√ß√£o!");
    } else {
      alert('Ordem Nula!');
    }
  }

// Torna as fun√ß√µes globais para o HTML conseguir acessar
window.litlegot = litlegot;
window.abrax = abrax;
window.psique = psique;
window.yellowfer = yellowfer;
window.lindenbergue = lindenbergue;
window.beast = beast;
  // --- Fun√ß√µes de Renderiza√ß√£o de Chat ---

  function renderGlobalChat() {
    const chatDisplay = document.getElementById('globalChatDisplay');
    if (!chatDisplay) return; // Ensure element exists

    // Show the global chat display only if an interface is active
    if (currentActiveHero) {
      chatDisplay.style.display = 'block';
    } else {
      chatDisplay.style.display = 'none';
    }

    chatDisplay.innerHTML = '';
    globalChatMessages.forEach(msg => {
      const newMessageDiv = document.createElement('div');
      newMessageDiv.classList.add('chat-message');

      if (msg.sender === 'Sistema') {
        newMessageDiv.classList.add('system-message');
      }

      // Apply Abrax inversion visual effect ONLY if the message original sender is the target AND Abrax power is active
      if (invertedChatState.active && invertedChatState.targetHero === msg.originalSender) {
          newMessageDiv.classList.add('abrax-inverted-chat-effect');
      }

      // Apply Akumatized message style (for the original akumatized sender)
      if (akumatizedEffectOnChat.active && akumatizedEffectOnChat.name === msg.originalSender) {
          newMessageDiv.classList.add('akumatized-message-style');
      }

      newMessageDiv.innerHTML = `<strong>${msg.sender}:</strong> ${msg.message}`;
      chatDisplay.appendChild(newMessageDiv);
    });
    chatDisplay.scrollTop = chatDisplay.scrollHeight;
  }

  function renderAkumaChat() {
    const akumaChatDisplay = document.getElementById('akumaChatDisplay');
    const akumaChatArea = document.querySelector('.akuma-chat-area');

    // Hide akuma chat if not active
    if (!akumaState.name || !akumaState.privateChatActive) {
        if (akumaChatDisplay) akumaChatDisplay.style.display = 'none';
        if (akumaChatArea) akumaChatArea.style.display = 'none';
        return;
    } else {
        if (akumaChatDisplay) akumaChatDisplay.style.display = 'block';
        if (akumaChatArea) akumaChatArea.style.display = 'flex'; // Ensure flex for its container
    }

    if (!akumaChatDisplay) return; // Ensure element exists after visibility check

    akumaChatDisplay.innerHTML = '';
    akumaChatMessages.forEach(msg => {
      const newMessageDiv = document.createElement('div');
      newMessageDiv.classList.add('chat-message');
      if (msg.sender === 'Sistema') {
        newMessageDiv.classList.add('system-message');
      }
      newMessageDiv.innerHTML = `<strong>${msg.sender}:</strong> ${msg.message}`;
      akumaChatDisplay.appendChild(newMessageDiv);
    });
    akumaChatDisplay.scrollTop = akumaChatDisplay.scrollHeight;
  }

  // --- Fun√ß√µes de Estado da Transforma√ß√£o e Poderes ---

  let transformTimers = {}; // Mapeia her√≥i para o ID do setTimeout

  function startTransformTimer(heroName) {
    if (evolvedHeroes[heroName] || (psiqueGrantedPower.active && psiqueGrantedPower.targetHero === heroName && psiqueGrantedPower.grantedPowerType === 'poder_ilimitado')) {
      console.log(`${heroName} evoluiu ou tem poder ilimitado, sem timer de 5 minutos.`);
      hideDestransformTimer();
      return;
    }

    console.log(`Iniciando timer de 5 minutos para ${heroName}.`);
    const endTime = Date.now() + FIVE_MINUTES_MS;
    set(ref(database, `heroTransformEndTimes/${heroName}`), endTime); // Save to Firebase

    // Also store in localStorage for persistence across refreshes
    const storedEndTimes = JSON.parse(localStorage.getItem('heroTransformEndTimes') || '{}');
    storedEndTimes[heroName] = endTime;
    localStorage.setItem('heroTransformEndTimes', JSON.stringify(storedEndTimes));


    if (transformTimers[heroName]) {
      clearTimeout(transformTimers[heroName]);
    }

    updateDestransformTimerDisplay(heroName, endTime);

    transformTimers[heroName] = setTimeout(() => {
      alert(`${heroName} destransformou!`);
      console.log(`${heroName} destransformou.`);
      resetHeroState(heroName);
      hideDestransformTimer();
      closeInterface(`${heroName.toLowerCase()}Interface`);
      // Remove from localStorage upon destransformation
      const storedEndTimes = JSON.parse(localStorage.getItem('heroTransformEndTimes') || '{}');
      delete storedEndTimes[heroName];
      localStorage.setItem('heroTransformEndTimes', JSON.stringify(storedEndTimes));
    }, FIVE_MINUTES_MS);
  }

  function updateDestransformTimerDisplay(heroName, endTime) {
    const timerDisplay = document.getElementById('destransformTimer');
    if (!timerDisplay) return; // Ensure element exists

    // Check if the hero is evolved or has unlimited power from Psique
    if (evolvedHeroes[heroName] || (psiqueGrantedPower.active && psiqueGrantedPower.targetHero === heroName && psiqueGrantedPower.grantedPowerType === 'poder_ilimitado')) {
      timerDisplay.style.display = 'none'; // Hide timer if evolved or has unlimited power
      if (destransformIntervalId) {
        clearInterval(destransformIntervalId);
        destransformIntervalId = null;
      }
      return;
    }

    timerDisplay.style.display = 'block';

    if (destransformIntervalId) {
      clearInterval(destransformIntervalId);
    }

    destransformIntervalId = setInterval(() => {
      const timeLeft = endTime - Date.now();
      if (timeLeft <= 0) {
        timerDisplay.innerText = '';
        timerDisplay.style.display = 'none';
        clearInterval(destransformIntervalId);
        destransformIntervalId = null;
      } else {
        const minutes = Math.floor(timeLeft / (60 * 1000));
        const seconds = Math.floor((timeLeft % (60 * 1000)) / 1000);
        timerDisplay.innerText = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
    }, 1000);
  }

  function hideDestransformTimer() {
    const timerDisplay = document.getElementById('destransformTimer');
    if (timerDisplay) {
      timerDisplay.style.display = 'none';
    }
    if (destransformIntervalId) {
      clearInterval(destransformIntervalId);
      destransformIntervalId = null;
    }
  }

  async function resetHeroState(heroName) {
    await set(ref(database, `powerUsedState/${heroName}`), false);

    if (transformTimers[heroName]) {
      clearTimeout(transformTimers[heroName]);
      delete transformTimers[heroName];
    }
    await remove(ref(database, `heroTransformEndTimes/${heroName}`)); // Remove from Firebase

    // Remove from localStorage
    const storedEndTimes = JSON.parse(localStorage.getItem('heroTransformEndTimes') || '{}');
    delete storedEndTimes[heroName];
    localStorage.setItem('heroTransformEndTimes', JSON.stringify(storedEndTimes));

    // Reset specific power states in Firebase
    if (heroName === 'Litlegot') {
      await set(litlegotCreatedItemRef, null);
    }
    if (heroName === 'Abrax') {
      if (abraxPuppetStringsState.active && abraxPuppetStringsState.targetHero) {
          alert(`As cordas de fantoche de ${abraxPuppetStringsState.targetHero} foram desativadas pois Abrax destransformou.`);
          await push(globalChatRef, { sender: 'Sistema', message: `As cordas de fantoche de ${abraxPuppetStringsState.targetHero} foram desativadas devido √† destransforma√ß√£o de Abrax!`, timestamp: Date.now() });
          await set(abraxPuppetStringsStateRef, { active: false, targetHero: '', messagesLeft: 0 });
      }
      if (invertedChatState.active && invertedChatState.targetHero) {
          alert(`${invertedChatState.targetHero}'s chat is no longer inverted as Abrax destransformed.`);
          await push(globalChatRef, { sender: 'Sistema', message: `${invertedChatState.targetHero}'s chat is no longer INVERTED due to Abrax's destransformation!`, timestamp: Date.now() });
          await set(invertedChatStateRef, { active: false, targetHero: '' });
      }
      await set(abraxSelfGrantedPowerRef, null);
    }
    if (heroName === 'Psique') {
      await set(akumaStateRef, { name: "", akumaChat: [], power: "", privateChatActive: false });
      await set(akumaChatRef, {}); // Clear akuma chat history (set to empty object, not array for Firebase)
      await set(akumatizedEffectOnChatRef, { active: false, name: '', distortedMessages: false });
      if (akumaState.name) { // If someone was akumatized by Psique
          await set(ref(database, `chatBlockedState/${akumaState.name}`), false);
      }
      // Reset granted power by Psique
      if (psiqueGrantedPower.active && psiqueGrantedPower.granter === heroName) {
        alert(`O poder concedido a ${psiqueGrantedPower.targetHero} foi desativado com a destransforma√ß√£o de Psique.`);
        await push(globalChatRef, { sender: 'Sistema', message: `O poder concedido a ${psiqueGrantedPower.targetHero} por Psique foi desativado!`, timestamp: Date.now() });
        await set(psiqueGrantedPowerRef, { active: false, targetHero: '', grantedPowerType: '', usesRemaining: 0, granter: '' });
      }
    }
    if (heroName === 'Yellowfer') {
      await set(yellowferSecondChanceActiveRef, false);
      await set(yellowferSecondChanceTimeRef, null);
      const secondChanceStatus = document.getElementById('secondChanceStatus');
      if (secondChanceStatus) secondChanceStatus.innerText = '';
    }
    if (heroName === 'Lindenbergue') {
      await set(chatRedirectStateRef, { active: false, fromHero: '', toHero: '' });
    }
    if (heroName === 'Beast') {
      await set(beastControlledElementsRef, []);
      // Ensure any chat block by Beast is removed
      for (const hero of HERO_NAMES) {
          const blocked = (await get(ref(database, `chatBlockedState/${hero}`))).val();
          if (blocked) {
              await set(ref(database, `chatBlockedState/${hero}`), false);
              alert(`${hero}'s chat has been unblocked as Beast destransformed.`);
              await push(globalChatRef, { sender: 'Sistema', message: `${hero}'s chat has been UNBLOCKED due to Beast's destransformation!`, timestamp: Date.now() });
          }
      }
    }
    renderGlobalChat(); // Re-render to clear visual effects and statuses
  }

  function showInterface(interfaceId, heroName) {
    document.querySelectorAll('.hero-interface, .power-interface').forEach(el => el.style.display = 'none');
    document.getElementById('heroButtons').style.display = 'none';

    const interfaceElement = document.getElementById(interfaceId);
    if (interfaceElement) {
        interfaceElement.style.display = 'flex';
    }
    currentActiveHero = heroName;
    localStorage.setItem('lastActiveHero', heroName); // Store last active hero

    const endTime = transformEndTimes[heroName];
    if (endTime && !evolvedHeroes[heroName] && !(psiqueGrantedPower.active && psiqueGrantedPower.targetHero === heroName && psiqueGrantedPower.grantedPowerType === 'poder_ilimitado')) {
        updateDestransformTimerDisplay(heroName, endTime);
    } else {
        hideDestransformTimer();
    }

    if (heroName === 'Psique') {
        updateAkumaDisplay();
        renderAkumaChat();
    }
    renderGlobalChat(); // Always render global chat to reflect current states/effects
  }

  function closeInterface(interfaceId) {
    const interfaceElement = document.getElementById(interfaceId);
    if (interfaceElement) {
      interfaceElement.style.display = 'none';
    }
    document.getElementById('heroButtons').style.display = 'block';
    currentActiveHero = null;
    localStorage.removeItem('lastActiveHero'); // Clear last active hero
    hideDestransformTimer();
  }

  function showPowerInterface(powerInterfaceId, heroName, chatInputId) {
    document.querySelectorAll('.hero-interface').forEach(el => el.style.display = 'none');
    const powerInterfaceElement = document.getElementById(powerInterfaceId);
    if (powerInterfaceElement) {
        powerInterfaceElement.style.display = 'flex';
    }
    localStorage.setItem('lastChatInputId', chatInputId);
    localStorage.setItem('lastActiveHero', heroName); // Still useful to know which hero was active
    currentActiveHero = heroName;

    // Hide the chat input area when a power interface is shown
    const chatInputParent = document.getElementById(chatInputId)?.parentElement;
    if (chatInputParent) {
      chatInputParent.style.display = 'none';
    }
  }

  function closePowerInterface(powerInterfaceId) {
    const powerInterfaceElement = document.getElementById(powerInterfaceId);
    if (powerInterfaceElement) {
      powerInterfaceElement.style.display = 'none';
    }

    const lastChatInputId = localStorage.getItem('lastChatInputId');
    const lastActiveHero = localStorage.getItem('lastActiveHero');

    // Show the corresponding hero interface and its chat input area
    if (lastActiveHero) {
      const heroInterfaceId = `${lastActiveHero.toLowerCase()}Interface`;
      const heroInterfaceElement = document.getElementById(heroInterfaceId);
      if (heroInterfaceElement) {
        heroInterfaceElement.style.display = 'flex';
        const chatInputParent = document.getElementById(lastChatInputId)?.parentElement;
        if (chatInputParent) {
          chatInputParent.style.display = 'flex';
        }
      }
    }
    localStorage.removeItem('lastChatInputId'); // Clean up
  }

  // Escutar ENTER para enviar mensagens no chat
  document.addEventListener('keypress', function (e) {
    if (e.key === 'Enter') {
      const activeInterface = document.querySelector('.hero-interface[style*=\"display: flex\"]');
      if (activeInterface) {
        const heroId = activeInterface.id.replace('Interface', '');
        const senderName = heroId.charAt(0).toUpperCase() + heroId.slice(1);
        const chatInput = document.getElementById(`chatInput_${heroId}`);
        const akumaChatInput = document.getElementById('akumaChatInput');

        if (chatInput && document.activeElement === chatInput) {
          sendMessage(senderName, heroId);
        } else if (heroId === 'psique' && akumaChatInput && document.activeElement === akumaChatInput) {
          sendAkumaMessage(senderName);
        } else if (
          akumaState.privateChatActive &&
          akumaState.name === senderName &&
          akumaChatInput &&
          document.activeElement === akumaChatInput
        ) {
          sendAkumaMessage(senderName); // Akumatized person's chat
        }
      }
    }
  });

  // --- Fun√ß√µes de Chat ---
  async function sendMessage(senderName, heroId) {
    const chatInput = document.getElementById(`chatInput_${heroId}`);
    let message = chatInput.value.trim();
    if (!message) {
      return;
    }

    if (chatBlockedState[senderName]) {
      alert(`${senderName}: Meu chat est√° bloqueado! N√£o consigo enviar mensagens!`);
      chatInput.value = '';
      return;
    }

    // NOVO: Impedir comandos se o chat estiver invertido
    if (invertedChatState.active && invertedChatState.targetHero === senderName && message.startsWith('/')) {
      alert(`${senderName}: Seu chat est√° invertido! N√£o √© poss√≠vel usar comandos agora.`);
      chatInput.value = '';
      return;
    }

    // Check for Abrax Puppet Strings
    if (abraxPuppetStringsState.active && abraxPuppetStringsState.targetHero === senderName && abraxPuppetStringsState.messagesLeft > 0) {
        const originalMessage = message;
        message = `(Via ${senderName}) ${message}`; // Prepend with info
        senderName = abraxPuppetStringsState.targetHero; // Send as target hero
        await set(abraxPuppetStringsStateRef, { ...abraxPuppetStringsState, messagesLeft: abraxPuppetStringsState.messagesLeft - 1 });
        if (abraxPuppetStringsState.messagesLeft - 1 <= 0) {
            alert(`As cordas de fantoche de ${senderName} foram desativadas.`);
            await push(globalChatRef, { sender: 'Sistema', message: `As cordas de fantoche de ${senderName} foram desativadas.`, timestamp: Date.now() });
            await set(abraxPuppetStringsStateRef, { active: false, targetHero: '', messagesLeft: 0 });
        }
        await push(globalChatRef, { sender: senderName, message: originalMessage, originalSender: heroId.charAt(0).toUpperCase() + heroId.slice(1), timestamp: Date.now() });
        chatInput.value = '';
        return;
    }

    // Check for Lindenbergue Redirect
    let finalSender = senderName;
    let finalMessage = message;
    let originalSender = senderName; // Keep track of the actual sender for effects like inversion/akuma

    if (chatRedirectState.active && chatRedirectState.fromHero === senderName) {
      finalSender = chatRedirectState.toHero;
      finalMessage = `(Redirecionado de ${senderName}) ${message}`;
      alert(`Sua mensagem foi redirecionada para ${finalSender}!`);
    }

    // Check for AKUMATIZED CHAT EFFECT (Psique)
    if (akumatizedEffectOnChat.active && akumatizedEffectOnChat.name && akumatizedEffectOnChat.name === originalSender) {
        if (akumatizedEffectOnChat.distortedMessages) {
            finalMessage = `~ ${finalMessage.split('').reverse().join('')} ~`;
        }
        finalSender = `Akumatizado (${originalSender})`;
    }

    // Check for INVERTED CHAT EFFECT (Abrax) - This is for the *sender's view* and message content.
    // The visual inversion for the *target* is handled in renderGlobalChat based on invertedChatState.targetHero
    if (invertedChatState.active && invertedChatState.targetHero === originalSender) {
        const words = finalMessage.split(' ');
        const invertedWords = words.map(word => word.split('').reverse().join(''));
        finalMessage = invertedWords.reverse().join(' ');
        alert(`Sua mensagem foi invertida por Abrax: "${finalMessage}"`); // Alert the sender
    }

    if (message.startsWith('/')) {
      const commandProcessed = await parseCommand(message, senderName);
      if (commandProcessed) {
        chatInput.value = '';
        return;
      }
      alert(`Comando "${message}" inv√°lido ou n√£o aplic√°vel para ${senderName}.`);
    }

    await push(globalChatRef, { sender: finalSender, message: finalMessage, originalSender: originalSender, timestamp: Date.now() });
    chatInput.value = '';
  }

  async function sendAkumaMessage(senderName) {
    const akumaChatInput = document.getElementById('akumaChatInput');
    let message = akumaChatInput.value.trim();
    if (!message) {
      return;
    }

    if (!akumaState.privateChatActive || akumaState.name === "") {
        alert("Nenhum akumatizado ativo para conversar ou chat privado n√£o est√° ativo.");
        akumaChatInput.value = '';
        return;
    }

    const newMessage = { sender: senderName, message: message, timestamp: Date.now() };
    await push(akumaChatRef, newMessage);
    akumaChatInput.value = '';
  }


  // --- Fun√ß√µes de Ativa√ß√£o de Poderes ---
  async function parseCommand(fullCommand, heroName) {
    const parts = fullCommand.toLowerCase().split(' ');
    const command = parts[0];
    const args = parts.slice(1);

    let hasGrantedPower = false;
    let grantedPowerCommand = '';
    // Check if the hero has a granted power from Psique
    if (psiqueGrantedPower.active && psiqueGrantedPower.targetHero === heroName) {
        if (psiqueGrantedPower.usesRemaining > 0 || psiqueGrantedPower.infinite) {
            if (psiqueGrantedPower.grantedPowerType === 'poder_ilimitado' && HERO_NAMES.includes(heroName)) {
                alert(`${heroName}: Voc√™ possui poder ilimitado!`);
                // This power type usually just removes the timer, no specific command needed here.
                // The timer logic is already updated by the onValue listener for psiqueGrantedPowerRef
                return true; // Command consumed
            } else if (psiqueGrantedPower.grantedPowerType === 'criar_item' && (command === '/genesis' || command === '/criar_item')) {
                hasGrantedPower = true;
                grantedPowerCommand = '/genesis';
            } else if (psiqueGrantedPower.grantedPowerType === 'reverter_tempo' && (command === '/segundachance' || command === '/voltar')) {
                hasGrantedPower = true;
                grantedPowerCommand = command;
            } else if (psiqueGrantedPower.grantedPowerType === 'silenciar_beast' && (command === '/dragao_silenciar' || command === '/silenciar')) { // Adjusted to silenciar_beast
                hasGrantedPower = true;
                grantedPowerCommand = '/dragao_silenciar';
            }
        }
    }

    // Check if power is already used for the hero, UNLESS it's a specific exception
    const isYellowferSecondChanceCommand = (heroName === 'Yellowfer' && command === '/segundachance');
    const isYellowferVoltarCommand = (heroName === 'Yellowfer' && command === '/voltar');
    const isBeastDragonCommand = (heroName === 'Beast' && command === '/dragao');
    const isEvolveCommand = (command === '/evoluir');
    const isHelpCommand = (command === '/ajuda');
    const isInverterCommand = (heroName === 'Abrax' && command === '/inverter');
    const isLitlegotUseCommand = (heroName === 'Litlegot' && command === '/usar');
    const isAbraxOtherPowerCommand = (heroName === 'Abrax' && ABRAX_PREDEFINED_POWERS.includes(command.substring(1))); // Checks if it's an Abrax power
    const isPsiqueAkumatizacaoCommand = (heroName === 'Psique' && command === '/akumatizacao');
    const isPsiqueConcedePowerCommand = (heroName === 'Psique' && command === '/conceder_poder');

    const bypassPowerUsedCheck = isYellowferSecondChanceCommand || isYellowferVoltarCommand || isBeastDragonCommand || isEvolveCommand || isHelpCommand || isInverterCommand || isLitlegotUseCommand || isAbraxOtherPowerCommand || hasGrantedPower || isPsiqueAkumatizacaoCommand || isPsiqueConcedePowerCommand;

    const usedPowerStatus = (await get(ref(database, `powerUsedState/${heroName}`))).val(); // Fetch current powerUsedState for the hero

    if (usedPowerStatus && !bypassPowerUsedCheck) {
        alert(`${heroName}: Meu poder j√° foi usado nesta transforma√ß√£o!`);
        return true; // Command consumed, but power not used
    }

    // Mark power as used ONLY if it's not a bypass and it's a "main" power use
    if (!bypassPowerUsedCheck) { // If it's a command that consumes power for the hero
        await set(ref(database, `powerUsedState/${heroName}`), true);
        startTransformTimer(heroName);
    } else if ( (command === '/segundachance' && heroName === 'Yellowfer' && !yellowferSecondChanceActive) || (command === '/dragao' && heroName === 'Beast' && beastControlledElements.length < 3)) { // Only marks as used when 3 elements are hit for Beast, or Second Chance is activated for Yellowfer
        if (command === '/segundachance' && heroName === 'Yellowfer' && !yellowferSecondChanceActive) {
            await set(ref(database, `powerUsedState/${heroName}`), true);
            startTransformTimer(heroName);
        } else if (command === '/dragao' && heroName === 'Beast') {
             // PowerUsed state for Beast will be handled within activateDragao
             // Timer will also be handled there when 3 elements are activated
        }
    }


    switch (command) {
      case '/genesis':
      case '/criar_item': // Alias for genesis, especially if granted by Psique
        if (heroName === 'Litlegot' || (hasGrantedPower && grantedPowerCommand === '/genesis')) {
          showPowerInterface('litlegotGenesisInterface', heroName, `chatInput_litlegot`);
          if (hasGrantedPower && !psiqueGrantedPower.infinite) {
             await set(psiqueGrantedPowerRef, { ...psiqueGrantedPower, usesRemaining: psiqueGrantedPower.usesRemaining - 1 });
          }
          return true;
        }
        break;
      case '/usar':
        if (heroName === 'Litlegot') {
          await activateLitlegotUse(args);
          return true;
        }
        break;
      case '/sublimacao':
        if (heroName === 'Abrax') {
          await activateSublimacao();
          return true;
        }
        break;
      case '/inverter':
        if (heroName === 'Abrax' && abraxSelfGrantedPower === 'inversao') {
          await activateAbraxInverter(args);
          await set(abraxSelfGrantedPowerRef, null); // Consume power
          return true;
        } else if (heroName === 'Abrax' && abraxSelfGrantedPower) {
          alert(`Abrax: Voc√™ n√£o possui o poder de Invers√£o. Voc√™ possui o poder de "${abraxSelfGrantedPower}".`);
          return true;
        } else if (heroName === 'Abrax') {
          alert('Abrax: Voc√™ n√£o possui nenhum poder concedido. Use /sublimacao primeiro.');
          return true;
        }
        break;
      case '/oraculo':
        if (heroName === 'Abrax' && abraxSelfGrantedPower === 'oraculo') {
          await activateAbraxOraculo();
          await set(abraxSelfGrantedPowerRef, null); // Consume power
          return true;
        } else if (heroName === 'Abrax' && abraxSelfGrantedPower) {
          alert(`Abrax: Voc√™ n√£o possui o poder de Or√°culo. Voc√™ possui o poder de "${abraxSelfGrantedPower}".`);
          return true;
        }
        break;
      case '/cordasdefantoche':
        if (heroName === 'Abrax' && abraxSelfGrantedPower === 'cordas de fantoche') {
          await activateAbraxCordasDeFantoche(args[0]);
          await set(abraxSelfGrantedPowerRef, null); // Consume power
          return true;
        } else if (heroName === 'Abrax' && abraxSelfGrantedPower) {
          alert(`Abrax: Voc√™ n√£o possui o poder de Cordas de Fantoche. Voc√™ possui o poder de "${abraxSelfGrantedPower}".`);
          return true;
        }
        break;
      case '/akumatizacao':
        if (heroName === 'Psique') {
          await activatePsiqueAkumatizacao();
          return true;
        }
        break;
      case '/conceder_poder':
        if (heroName === 'Psique') {
          await activatePsiqueConcedePower();
          return true;
        }
        break;
      case '/segundachance':
        if (heroName === 'Yellowfer' || (hasGrantedPower && (grantedPowerCommand === '/segundachance' || grantedPowerCommand === '/voltar'))) {
          showPowerInterface('yellowferSecondChanceInterface', heroName, `chatInput_yellowfer`);
          if (hasGrantedPower && !psiqueGrantedPower.infinite) {
            await set(psiqueGrantedPowerRef, { ...psiqueGrantedPower, usesRemaining: psiqueGrantedPower.usesRemaining - 1 });
          }
          return true;
        }
        break;
      case '/voltar':
        if (heroName === 'Yellowfer' || (hasGrantedPower && (grantedPowerCommand === '/segundachance' || grantedPowerCommand === '/voltar'))) {
          await activateYellowferVoltar(heroName);
          if (hasGrantedPower && !psiqueGrantedPower.infinite) {
            await set(psiqueGrantedPowerRef, { ...psiqueGrantedPower, usesRemaining: psiqueGrantedPower.usesRemaining - 1 });
          }
          return true;
        }
        break;
      case '/viajar':
        if (heroName === 'Lindenbergue') {
          showPowerInterface('lindenbergueViajarInterface', heroName, `chatInput_lindenbergue`);
          return true;
        }
        break;
      case '/dragao':
        if (heroName === 'Beast') {
          showPowerInterface('beastDragaoInterface', heroName, `chatInput_beast`);
          return true;
        }
        break;
      case '/dragao_silenciar': // Granted silence power by Psique, for Beast-like control
        if (hasGrantedPower && grantedPowerCommand === '/dragao_silenciar') {
          await activateBeastSilence(args, heroName); // Reuses Beast's silence logic
          if (hasGrantedPower && !psiqueGrantedPower.infinite) {
            await set(psiqueGrantedPowerRef, { ...psiqueGrantedPower, usesRemaining: psiqueGrantedPower.usesRemaining - 1 });
          }
          return true;
        }
        break;
      case '/evoluir':
        if (HERO_NAMES.includes(heroName)) {
          evolveHero(heroName);
          return true;
        }
        break;
      case '/ajuda':
        let helpMessage = "Comandos de Poderes:\n\n";
        helpMessage += "Litlegot: /genesis (Cria um item) & /usar [item] (Consome o item criado para desbloquear chat/buff)\n";
        helpMessage += "Abrax: /sublimacao (Concede a si um poder da lista: " + ABRAX_PREDEFINED_POWERS.map(p => `"${p}"`).join(', ') + ")\n";
        helpMessage += "Abrax: /inverter [heroi] (Se tiver 'inversao', inverte a leitura do chat do her√≥i alvo)\n";
        helpMessage += "Abrax: /oraculo (Se tiver 'oraculo', v√™ as 5 √∫ltimas mensagens do chat)\n";
        helpMessage += "Abrax: /cordasdefantoche [heroi] (Se tiver 'cordas de fantoche', suas 3 pr√≥ximas msgs ser√£o enviadas pelo her√≥i alvo)\n";
        helpMessage += "Psique: /akumatizacao (Akumatiza algu√©m, pode bloquear/distorcer chat e opcionalmente abrir chat privado)\n";
        helpMessage += "Psique: /conceder_poder (Concede um poder tempor√°rio a outro her√≥i: " + PSIQUE_CONCEDE_POWERS.map(p => `"${p}"`).join(', ') + ")\n";
        helpMessage += "Yellowfer: /segundachance (Define um ponto de retorno no tempo) & /voltar (Reverte o chat, desfazendo mensagens recentes)\n";
        helpMessage += "Lindenbergue: /viajar (Abre portal, pode redirecionar/acessar chat de outro her√≥i)\n";
        helpMessage += "Beast: /dragao [elemento] (Controla elemento) & /silenciar [heroi] (Silencia o chat de um her√≥i por 15s - APENAS SE FOR PODER CONCEDIDO)\n"; // Clarified Beast silence
        alert(helpMessage);
        return true;
        break;
      default:
        return false; // Command not recognized or not handled here
    }
    return false; // Fallback if no command matched
  }

  // --- Litlegot Powers ---
  async function activateGenesis() {
    const heroName = 'Litlegot';
    const objectName = document.getElementById('genesisObjectInput').value.trim();
    const outputDisplay = document.getElementById('genesisOutput');

    if (!objectName) {
      outputDisplay.innerText = 'Por favor, insira o nome do objeto a ser criado.';
      return;
    }
    if (litlegotCreatedItem) {
        outputDisplay.innerText = `Voc√™ j√° criou um item: "${litlegotCreatedItem}". Use-o primeiro com /usar.`;
        return;
    }

    await set(litlegotCreatedItemRef, objectName);
    await push(globalChatRef, { sender: 'Sistema', message: `${heroName} criou um item: "${objectName}"!`, timestamp: Date.now() });
    outputDisplay.innerText = `Item "${objectName}" criado com sucesso!`;
  }

  async function activateLitlegotUse(args) {
    const heroName = 'Litlegot';
    const itemToUse = args.join(' ').trim();
    if (!itemToUse) {
        alert('Litlegot: Qual item deseja usar? Use: /usar [nome do item]');
        return;
    }
    if (!litlegotCreatedItem) {
        alert('Litlegot: Nenhum item para ser usado.');
        return;
    }
    if (itemToUse.toLowerCase() === litlegotCreatedItem.toLowerCase()) {
        alert(`${heroName} usou "${litlegotCreatedItem}"!`);
        await push(globalChatRef, { sender: 'Sistema', message: `${heroName} usou o item "${litlegotCreatedItem}" criado por Litlegot!`, timestamp: Date.now() });
        // Real effect: Unblock the user's chat if blocked
        const targetChatBlocked = (await get(ref(database, `chatBlockedState/${heroName}`))).val();
        if (targetChatBlocked) {
            await set(ref(database, `chatBlockedState/${heroName}`), false);
            alert(`${heroName}: Meu chat foi desbloqueado pelo item "${litlegotCreatedItem}"!`);
            await push(globalChatRef, { sender: 'Sistema', message: `${heroName}'s chat has been UNBLOCKED by the item!`, timestamp: Date.now() });
        } else {
            alert(`${heroName}: Senti um pequeno buff de comunica√ß√£o!`);
            await push(globalChatRef, { sender: 'Sistema', message: `${heroName} received a communication buff!`, timestamp: Date.now() });
        }
        await set(litlegotCreatedItemRef, null); // Consume the item
        return true;
    } else {
        alert(`Item "${itemToUse}" n√£o encontrado ou n√£o corresponde ao item criado.`);
        return false;
    }
  }

  // --- Abrax Powers ---
  async function activateSublimacao() {
    const heroName = 'Abrax';
    const powersList = ABRAX_PREDEFINED_POWERS.map((p, i) => `${i + 1}. ${p}`).join('\n');
    const choice = prompt(`Abrax: Escolha um poder para sublimar:\n${powersList}\nDigite o nome exato ou o n√∫mero correspondente:`);
    let powerToGrant = null;

    if (choice) {
      const parsedChoice = parseInt(choice);
      if (!isNaN(parsedChoice) && parsedChoice >= 1 && parsedChoice <= ABRAX_PREDEFINED_POWERS.length) {
        powerToGrant = ABRAX_PREDEFINED_POWERS[parsedChoice - 1];
      } else if (ABRAX_PREDEFINED_POWERS.includes(choice.toLowerCase())) {
        powerToGrant = choice.toLowerCase();
      }
    }

    if (!powerToGrant) {
      alert('Abrax: Escolha de poder inv√°lida. Sublima√ß√£o cancelada.');
      return;
    }

    await set(abraxSelfGrantedPowerRef, powerToGrant);
    alert(`Abrax: Voc√™ concedeu a si mesmo o poder de "${powerToGrant}"! Use /${powerToGrant} para ativ√°-lo.`);
    await push(globalChatRef, { sender: 'Sistema', message: `Abrax sublimou e concedeu a si mesmo o poder: "${powerToGrant}"!`, timestamp: Date.now() });
    document.getElementById('sublimacaoOutput').innerText = `Poder concedido: "${powerToGrant}"`;
  }

  async function activateAbraxInverter(args) {
    const heroName = 'Abrax';
    const targetHero = args.join(' ').trim();
    if (!targetHero || !HERO_NAMES.includes(targetHero)) {
      alert('Abrax: Alvo inv√°lido. Especifique um her√≥i v√°lido para inverter.');
      return;
    }
    if (targetHero === heroName) {
      alert('Abrax: Voc√™ n√£o pode inverter seu pr√≥prio chat.');
      return;
    }

    alert(`Abrax: Voc√™ ativou Invers√£o no chat de ${targetHero}!`);
    await push(globalChatRef, { sender: 'Sistema', message: `Abrax usou Invers√£o no chat de ${targetHero}!`, timestamp: Date.now() });
    await set(invertedChatStateRef, { active: true, targetHero: targetHero });

    setTimeout(async () => {
      await set(invertedChatStateRef, { active: false, targetHero: '' });
      alert(`Abrax: O chat de ${targetHero} voltou ao normal!`);
      await push(globalChatRef, { sender: 'Sistema', message: `O chat de ${targetHero} voltou ao normal!`, timestamp: Date.now() });
    }, 30000); // Inverte por 30 segundos
  }

  async function activateAbraxOraculo() {
    const heroName = 'Abrax';
    const lastFiveMessages = globalChatMessages.slice(-5); // Get last 5 messages
    let oracleOutput = "Abrax (Or√°culo): √öltimas 5 mensagens do chat:\n\n";

    if (lastFiveMessages.length === 0) {
      oracleOutput += "Nenhuma mensagem no chat ainda.";
    } else {
      lastFiveMessages.forEach(msg => {
        const date = new Date(msg.timestamp);
        oracleOutput += `- ${msg.sender} (${date.toLocaleTimeString()}): ${msg.message}\n`;
      });
    }
    alert(oracleOutput);
    await push(globalChatRef, { sender: 'Sistema', message: `Abrax usou Or√°culo para ver o fluxo do tempo!`, timestamp: Date.now() });
  }

  async function activateAbraxCordasDeFantoche(targetHero) {
    const heroName = 'Abrax';
    const trimmedTargetHero = targetHero ? targetHero.trim() : '';

    if (!HERO_NAMES.includes(trimmedTargetHero) || trimmedTargetHero === heroName) {
      alert('Abrax: Alvo inv√°lido ou voc√™ n√£o pode controlar a si mesmo.');
      return;
    }
    alert(`Abrax: Voc√™ ativou Cordas de Fantoche em ${trimmedTargetHero}! Suas pr√≥ximas 3 mensagens ser√£o enviadas como se fossem dele(a).`);
    await push(globalChatRef, { sender: 'Sistema', message: `Abrax usou Cordas de Fantoche em ${trimmedTargetHero}.`, timestamp: Date.now() });
    await set(abraxPuppetStringsStateRef, { active: true, targetHero: trimmedTargetHero, messagesLeft: 3 });
  }

  // --- Psique Powers ---
  async function updateAkumaDisplay() {
    const akumatizedNameDisplay = document.getElementById('akumatizedNameDisplay');
    if (akumatizedNameDisplay) {
        akumatizedNameDisplay.innerText = akumaState.name ? `${akumaState.name} (Poder: ${akumaState.power || 'N/A'})` : 'Ningu√©m';
    }
  }

  async function promptAkumaName() {
    const heroName = 'Psique';
    if (akumaState.name) {
      alert(`Psique: ${akumaState.name} j√° est√° akumatizado(a). Desakumatize-o(a) primeiro.`);
      return;
    }
    const personName = prompt("Psique: Quem voc√™ deseja akumatizar?");
    if (!personName || personName.trim() === '') {
      alert("Psique: Nome inv√°lido. Akumatiza√ß√£o cancelada.");
      return;
    }
    const akumaPower = prompt(`Psique: Qual poder de Akuma ${personName} ter√°? (Ex: bloqueio de voz, distor√ß√£o de mensagens)`);
    if (!akumaPower || akumaPower.trim() === '') {
      alert("Psique: Poder inv√°lido. Akumatiza√ß√£o cancelada.");
      return;
    }

    // Confirm activation of private chat
    const activatePrivateChat = confirm("Psique: Deseja ativar um chat privado com o akumatizado?");

    const newAkumaState = {
      name: personName.trim(),
      power: akumaPower.trim(),
      privateChatActive: activatePrivateChat
    };
    await set(akumaStateRef, newAkumaState);
    if (activatePrivateChat) {
      await set(akumaChatRef, {}); // Clear akuma chat history for new akumatization
    }

    alert(`Psique: ${personName} foi akumatizado(a)! Poder: ${akumaPower}`);
    await push(globalChatRef, { sender: 'Sistema', message: `Psique akumatizou: "${personName}"! Um novo vil√£o surgiu!`, timestamp: Date.now() });

    // REAL AKUMATIZATION EFFECTS
    const newAkumatizedEffectOnChat = { active: true, name: personName.trim(), distortedMessages: false };
    if (akumaPower.toLowerCase().includes('bloqueio de voz')) {
        await set(ref(database, `chatBlockedState/${personName.trim()}`), true);
        await push(globalChatRef, { sender: 'Sistema', message: `O chat de ${personName} est√° agora BLOQUEADO pelo poder de Akuma!`, timestamp: Date.now() });
    }
    if (akumaPower.toLowerCase().includes('distor√ß√£o de mensagens')) {
        newAkumatizedEffectOnChat.distortedMessages = true;
        await push(globalChatRef, { sender: 'Sistema', message: `As mensagens de ${personName} ser√£o DISTORCIDAS no chat!`, timestamp: Date.now() });
    }
    await set(akumatizedEffectOnChatRef, newAkumatizedEffectOnChat);
    renderAkumaChat(); // Update visibility based on privateChatActive

    // Mark Psique's power as used and start timer
    await set(ref(database, `powerUsedState/${heroName}`), true);
    startTransformTimer(heroName);
  }

  async function desakumatizar() {
    if (!akumaState.name) {
      alert("Psique: Ningu√©m akumatizado no momento.");
      return;
    }
    const confirmDesakuma = confirm(`Psique: Deseja desakumatizar ${akumaState.name}?`);
    if (confirmDesakuma) {
      const formerlyAkumatized = akumaState.name;
      alert(`Psique: ${formerlyAkumatized} foi desakumatizado(a)!`);
      await push(globalChatRef, { sender: 'Sistema', message: `Psique desakumatizou: "${formerlyAkumatized}"! A paz retornou!`, timestamp: Date.now() });

      // Reset Akuma states
      await set(akumaStateRef, { name: "", akumaChat: [], power: "", privateChatActive: false });
      await set(akumaChatRef, {}); // Clear akuma chat history
      await set(akumatizedEffectOnChatRef, { active: false, name: '', distortedMessages: false });
      await set(ref(database, `chatBlockedState/${formerlyAkumatized}`), false); // Unblock chat
      await set(ref(database, `powerUsedState/Psique`), false); // Reset Psique's power usage after desakumatizing
      hideDestransformTimer(); // Psique's timer would stop on desakumatization if it's her power that consumes it.
      resetHeroState('Psique'); // Reset Psique's state as well, including her timer
      renderAkumaChat();
    }
  }

  async function activatePsiqueConcedePower() {
    const heroName = 'Psique';
    // Check if Psique has already used her power
    if (powerUsedState[heroName]) {
      alert("Psique: Seu poder de conceder j√° foi usado nesta transforma√ß√£o.");
      return;
    }

    const targetHero = prompt("Psique: Para qual her√≥i voc√™ deseja conceder um poder? (Nome completo do her√≥i)");
    if (!HERO_NAMES.includes(targetHero) || targetHero === heroName) {
      alert('Psique: Alvo inv√°lido ou voc√™ n√£o pode conceder poder a si mesma.');
      return;
    }

    const powersList = PSIQUE_CONCEDE_POWERS.map((p, i) => `${i + 1}. ${p}`).join('\n');
    const powerType = prompt(`Psique: Qual poder deseja conceder a ${targetHero}?\n${powersList}\nDigite o nome exato ou o n√∫mero correspondente:`);
    let selectedPowerType = null;

    if (powerType) {
      const parsedChoice = parseInt(powerType);
      if (!isNaN(parsedChoice) && parsedChoice >= 1 && parsedChoice <= PSIQUE_CONCEDE_POWERS.length) {
        selectedPowerType = PSIQUE_CONCEDE_POWERS[parsedChoice - 1];
      } else if (PSIQUE_CONCEDE_POWERS.includes(powerType.toLowerCase())) {
        selectedPowerType = powerType.toLowerCase();
      }
    }

    if (!selectedPowerType) {
      alert('Psique: Escolha de poder inv√°lida. Concess√£o cancelada.');
      return;
    }

    let uses = 1;
    let isInfinite = false;
    if (selectedPowerType === 'poder_ilimitado') {
      isInfinite = true;
      uses = 9999; // Effectively infinite for the duration of Psique's transformation
    }

    await set(psiqueGrantedPowerRef, { active: true, granter: heroName, targetHero: targetHero, grantedPowerType: selectedPowerType, usesRemaining: uses, infinite: isInfinite });
    await set(ref(database, `powerUsedState/${heroName}`), true); // Psique used her power
    startTransformTimer(heroName);
    alert(`Psique: Voc√™ concedeu "${selectedPowerType}" a ${targetHero}!`);
    await push(globalChatRef, { sender: 'Sistema', message: `Psique concedeu o poder "${selectedPowerType}" a ${targetHero}!`, timestamp: Date.now() });
  }


  // --- Yellowfer Powers ---
  async function activateSecondChance() {
    const heroName = 'Yellowfer';
    const statusDisplay = document.getElementById('secondChanceStatus');

    if (yellowferSecondChanceActive) {
      alert("Yellowfer: Segunda Chance j√° est√° ativa.");
      return;
    }
    const currentTime = Date.now();
    await set(yellowferSecondChanceTimeRef, currentTime);
    await set(yellowferSecondChanceActiveRef, true);
    alert('Yellowfer: Segunda Chance ativada! Ponto de retorno definido.');
    await push(globalChatRef, { sender: 'Sistema', message: `${heroName} ativou Segunda Chance! O tempo pode ser revertido!`, timestamp: Date.now() });
    statusDisplay.innerText = `Segunda Chance Ativada! Ponto de retorno: ${new Date(currentTime).toLocaleTimeString()}`;
  }

  async function activateYellowferVoltar(heroName) {
    if (yellowferSecondChanceActive && yellowferSecondChanceTimestamp) {
        const timeAgo = Math.floor((Date.now() - yellowferSecondChanceTimestamp) / 1000);
        alert(`Yellowfer: Revertendo o tempo para o momento de ativa√ß√£o (${timeAgo} segundos atr√°s)!`);
        await push(globalChatRef, { sender: 'Sistema', message: `${heroName} (com poder de Yellowfer) reverteu o tempo! As √∫ltimas a√ß√µes foram desfeitas.`, timestamp: Date.now() });

        const numMessagesToRemove = parseInt(prompt("Yellowfer: Quantas mensagens deseja 'desfazer' (remover do chat)? (Recomendado: 1-5)"), 10);
        if (isNaN(numMessagesToRemove) || numMessagesToRemove <= 0) {
            alert("N√∫mero inv√°lido de mensagens para desfazer. Nenhuma mensagem removida.");
            return;
        }

        const messagesSnapshot = await get(globalChatRef);
        const messagesData = messagesSnapshot.val(); // This will be an object {key: message_object}
        if (!messagesData) {
            alert("Nenhuma mensagem para desfazer.");
            return;
        }

        const messageKeys = Object.keys(messagesData).sort((a, b) => messagesData[a].timestamp - messagesData[b].timestamp); // Sort keys by timestamp
        
        let keysToDelete = [];
        let messagesRemovedCount = 0;
        // Iterate backwards from the latest messages
        for (let i = messageKeys.length - 1; i >= 0 && messagesRemovedCount < numMessagesToRemove; i--) {
            const key = messageKeys[i];
            const message = messagesData[key];
            // Do not remove the current system message about Yellowfer reversing time
            if (!(message.sender === 'Sistema' && message.message.includes("reverteu o tempo!"))) {
                keysToDelete.push(key);
                messagesRemovedCount++;
            }
        }

        if (keysToDelete.length > 0) {
            const updates = {};
            keysToDelete.forEach(key => {
                updates[key] = null; // Set to null to delete
            });
            await update(globalChatRef, updates);
            alert(`${keysToDelete.length} mensagens foram desfeitas.`);
            await push(globalChatRef, { sender: 'Sistema', message: `${heroName} desfez as √∫ltimas ${keysToDelete.length} mensagens do chat!`, timestamp: Date.now() });
        } else {
            alert("Nenhuma mensagem foi desfeita.");
        }
    } else {
      alert("Segunda Chance n√£o est√° ativa ou ponto de retorno n√£o definido.");
    }
  }

  // --- Lindenbergue Powers ---
  async function activateViajar() {
    const heroName = 'Lindenbergue';
    const destination = document.getElementById('portalDestinationInput').value.trim();
    const portalStatusDisplay = document.getElementById('portalStatus');

    if (!destination) {
      portalStatusDisplay.innerText = 'Para onde deseja ir?';
      return;
    }

    // Check if Lindenbergue's power has been used
    const powerWasUsed = (await get(ref(database, `powerUsedState/${heroName}`))).val();
    if (powerWasUsed && chatRedirectState.active) { // If already redirected, can't open another portal. Assuming only one portal allowed
        alert("Lindenbergue: J√° existe um portal ativo ou redirecionamento. Feche-o primeiro.");
        portalStatusDisplay.innerText = `Portal j√° ativo para ${chatRedirectState.toHero}.`;
        return;
    }


    const confirmRedirect = confirm(`Lindenbergue: Deseja abrir um portal para "${destination}" e redirecionar mensagens de um her√≥i para seu chat?`);

    if (confirmRedirect) {
        const targetHeroToRedirect = prompt("Lindenbergue: Qual her√≥i ter√° suas mensagens redirecionadas para seu chat? (Nome completo do her√≥i)");
        if (!targetHeroToRedirect || !HERO_NAMES.includes(targetHeroToRedirect) || targetHeroToRedirect === heroName) {
            alert('Lindenbergue: Alvo inv√°lido ou voc√™ n√£o pode redirecionar seu pr√≥prio chat. Redirecionamento cancelado.');
            return;
        }

        const newChatRedirectState = {
            active: true,
            fromHero: targetHeroToRedirect,
            toHero: heroName,
            destination: destination // Store destination for narrative
        };
        await set(chatRedirectStateRef, newChatRedirectState);

        alert(`Lindenbergue: Portal para "${destination}" aberto! Mensagens de ${targetHeroToRedirect} ser√£o redirecionadas para o seu chat!`);
        await push(globalChatRef, { sender: 'Sistema', message: `Lindenbergue abriu um portal para "${destination}" e est√° REDIRECIONANDO as comunica√ß√µes de ${targetHeroToRedirect}!`, timestamp: Date.now() });
        portalStatusDisplay.innerText = `Portal aberto para "${destination}". Redirecionando mensagens de ${targetHeroToRedirect}.`;

    } else {
        alert(`Lindenbergue: Portal para "${destination}" aberto para visualiza√ß√£o.`);
        await push(globalChatRef, { sender: 'Sistema', message: `Lindenbergue abriu um portal para "${destination}" para monitoramento.`, timestamp: Date.now() });
        portalStatusDisplay.innerText = `Portal aberto para "${destination}" (monitorando).`;
    }

    await set(ref(database, `powerUsedState/${heroName}`), true);
    startTransformTimer(heroName);
  }

  // --- Beast Powers ---
  async function activateDragao() {
    const element = document.getElementById('dragonElementInput').value.trim().toLowerCase();
    const outputDisplay = document.getElementById('dragonStatus');
    const heroName = 'Beast';

    if (!element) {
      outputDisplay.innerText = 'Qual elemento deseja controlar?';
      return;
    }
    const validElements = ['fogo', 'agua', 'vento', 'terra'];
    if (!validElements.includes(element)) {
      outputDisplay.innerText = 'Elemento inv√°lido. Escolha Fogo, √Ågua, Vento ou Terra.';
      return;
    }

    let currentControlledElements = beastControlledElements;
    let newElementAdded = false;

    if (!currentControlledElements.includes(element)) {
      currentControlledElements = [...currentControlledElements, element];
      await set(beastControlledElementsRef, currentControlledElements);
      newElementAdded = true;
    } else {
        alert(`Beast: Voc√™ j√° controla o elemento ${element}.`);
        outputDisplay.innerText = `Beast j√° controla o elemento ${element}! Elementos controlados: ${currentControlledElements.map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(', ')}`;
        return; // Don't trigger timer if already controlling
    }

    outputDisplay.innerText = `Beast agora controla o elemento ${element}! Elementos controlados: ${currentControlledElements.map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(', ')}`;
    alert(`Beast agora controla o elemento ${element}!`);

    if (newElementAdded) {
      await push(globalChatRef, { sender: 'Sistema', message: `Beast ativou o elemento: ${element.charAt(0).toUpperCase() + element.slice(1)}!`, timestamp: Date.now() });

      if (currentControlledElements.length >= 3) {
        alert('Beast: Voc√™ ativou 3 elementos! O timer de 5 minutos foi iniciado.');
        await set(ref(database, `powerUsedState/${heroName}`), true); // Mark power as used only when 3 elements are hit
        startTransformTimer(heroName);
      }
    }
  }

  async function activateBeastSilence(args, grantedByHero = null) {
    const heroName = grantedByHero || 'Beast'; // If granted, the hero who granted it
    const targetHero = args.join(' ').trim();
    if (!targetHero || !HERO_NAMES.includes(targetHero) || targetHero === heroName) {
      alert(`${heroName}: Alvo inv√°lido ou voc√™ n√£o pode silenciar a si mesmo.`);
      return;
    }

    alert(`${heroName}: Silenciando o chat de ${targetHero} por 15 segundos!`);
    await set(ref(database, `chatBlockedState/${targetHero}`), true);
    await push(globalChatRef, { sender: 'Sistema', message: `${heroName} usou Sil√™ncio em ${targetHero}!`, timestamp: Date.now() });

    setTimeout(async () => {
      await set(ref(database, `chatBlockedState/${targetHero}`), false);
      alert(`${targetHero}'s chat foi desbloqueado!`);
      await push(globalChatRef, { sender: 'Sistema', message: `O chat de ${targetHero} foi desbloqueado!`, timestamp: Date.now() });
    }, 15000); // Silence for 15 seconds
  }

  // --- Evolu√ß√£o do Miraculous ---
  async function evolveHero(heroName) {
    const isEvolved = (await get(ref(database, `heroEvolved/${heroName}`))).val();
    if (isEvolved) {
      alert(`${heroName} j√° atingiu a evolu√ß√£o m√°xima e aboliu a regra dos 5 minutos!`);
      return;
    }
    const confirmEvolve = confirm(`Deseja evoluir o Miraculous de ${heroName}? Isso abolir√° a regra dos 5 minutos para ele!`);
    if (confirmEvolve) {
      await set(ref(database, `heroEvolved/${heroName}`), true);
      alert(`O Miraculous de ${heroName} evoluiu! A regra dos 5 minutos foi abolida para ${heroName}!`);
      if (transformTimers[heroName]) {
        clearTimeout(transformTimers[heroName]);
        delete transformTimers[heroName];
        await remove(ref(database, `heroTransformEndTimes/${heroName}`));
        hideDestransformTimer();
      }
      await push(globalChatRef, { sender: 'Sistema', message: `O Miraculous de ${heroName} EVOLUIU! O limite de tempo foi abolido!`, timestamp: Date.now() });
    }
  }
  </script>
</body>
</html>
