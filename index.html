<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Caixa de Miraculos</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Pacifico&display=swap');

    body {
      font-family: 'Rockwell', serif;
      margin: 0;
      padding: 0;
      background: url('https://i.imgur.com/your-background-image.jpg') no-repeat center center fixed;
      background-size: cover;
      color: #fff;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    .container {
      background-color: rgba(0, 0, 0, 0.7);
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
      width: 90%;
      max-width: 600px;
      text-align: center;
      position: relative;
    }

    h1 {
      font-size: 3em;
      color: #00ffff;
      text-shadow: 0 0 10px #00ffff, 0 0 20px #00ffff;
      margin-bottom: 20px;
      font-family: 'Pacifico', cursive;
    }

    .hero-buttons {
      margin-top: 20px;
    }

    .hero-buttons hr {
      border: none;
      border-top: 2px solid #00ffff;
      margin: 20px 0;
    }

    .hero-buttons button {
      background-color: #ff007f;
      color: #fff;
      border: none;
      padding: 15px 30px;
      font-size: 1.2em;
      font-family: 'Rockwell', serif;
      border-radius: 30px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(255, 0, 127, 0.4);
      width: 100%;
      margin-bottom: 10px;
    }

    .hero-buttons button:hover {
      background-color: #ff3399;
      transform: translateY(-3px);
      box-shadow: 0 8px 20px rgba(255, 0, 127, 0.6);
    }

    .hero-buttons p {
      margin-top: 5px;
      font-size: 1.1em;
      color: #eee;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.7);
    }

    /* Estilos base para todas as interfaces (chat e poderes) */
    .hero-interface, .power-interface {
      display: none; /* Hidden by default */
      background-color: rgba(0, 0, 0, 0.85);
      padding: 25px;
      border-radius: 10px;
      margin-top: 20px;
      box-shadow: 0 0 15px rgba(255, 255, 0, 0.7);
      animation: fadeIn 0.5s ease-in-out;
      flex-direction: column;
      height: 450px;
      box-sizing: border-box; /* Incluir padding na altura/largura */
    }

    /* Estilo espec√≠fico para interfaces de poder que podem ser menus */
    .power-interface {
      height: auto; /* Altura flex√≠vel para menus */
      min-height: 200px;
      justify-content: center;
      align-items: center;
      gap: 15px;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .hero-interface h2, .power-interface h2 {
      color: #ffd700;
      font-size: 2em;
      margin-bottom: 15px;
    }

    /* Estilos de chat */
    .chat-display {
      flex-grow: 1;
      background-color: rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      padding: 10px;
      margin-bottom: 15px;
      overflow-y: auto;
      text-align: left;
      font-size: 0.95em;
      line-height: 1.4;
      color: #e0e0e0;
      box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
    }

    .chat-message {
      margin-bottom: 8px;
    }

    .chat-message strong {
      color: #00ffff;
    }

    .chat-input-area {
      display: flex;
      gap: 10px;
      margin-top: auto;
    }

    .chat-input-area input[type="text"] {
      flex-grow: 1;
      padding: 10px;
      border-radius: 5px;
      border: 1px solid #00ffff;
      background-color: rgba(255, 255, 255, 0.15);
      color: #fff;
      font-family: 'Rockwell', serif;
      font-size: 1em;
    }

    .chat-input-area input[type="text"]::placeholder {
      color: #bbb;
    }

    .chat-input-area button {
      background-color: #008080;
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.3s ease;
      font-family: 'Rockwell', serif;
    }

    .chat-input-area button:hover {
      background-color: #006666;
    }

    .close-button {
      background-color: #dc3545;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      transition: background-color 0.3s ease;
      margin-top: 15px;
    }

    .close-button:hover {
      background-color: #c82333;
    }

    /* Estilos para bot√µes de poder dentro das interfaces */
    .power-interface button {
      background-color: #8A2BE2; /* Azul violeta */
      color: white;
      border: none;
      padding: 12px 25px;
      font-size: 1.1em;
      font-family: 'Rockwell', serif;
      border-radius: 20px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(138, 43, 226, 0.4);
      width: 80%; /* Ajuste a largura conforme necess√°rio */
      max-width: 300px;
      margin-bottom: 10px;
    }

    .power-interface button:hover {
      background-color: #9370DB; /* Roxa m√©dia */
      transform: translateY(-2px);
      box-shadow: 0 6px 15px rgba(138, 43, 226, 0.6);
    }

    .power-info {
      color: #e0e0e0;
      font-size: 0.9em;
      margin-bottom: 10px;
      line-height: 1.4;
      max-width: 90%;
    }

    .akuma-chat-area {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      gap: 10px;
    }

    .akuma-chat-area .chat-display {
      flex-grow: 1;
      height: 150px; /* Altura fixa para o chat do Akumatizado */
      min-height: 100px;
    }

    .akuma-control button {
      background-color: #ff4500; /* Laranja avermelhado */
      margin-right: 10px;
      margin-bottom: 10px;
    }
    .akuma-control button:hover {
      background-color: #cc3700;
    }

    /* Estilos para o timer de destransforma√ß√£o */
    .timer-display {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(255, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 1em;
      font-weight: bold;
      z-index: 100;
      display: none; /* Oculto por padr√£o */
    }

    /* Estilos adicionais para efeitos de chat */
    .abrax-inverted-chat-effect {
      transform: scaleX(-1);
      direction: rtl;
      unicode-bidi: bidi-override;
    }

    .akumatized-message-style {
      color: #ff0000;
      font-style: italic;
      text-decoration: wavy underline;
    }
  </style>
</head>
<body>
  <div class="container">
    <center>
      <h1>‚Ä¢¬∞‚Ä¢Aurore Boreale¬∞‚Ä¢¬∞‚Ä¢</h1>
    </center>

    <div class="hero-buttons" id="heroButtons">
      <hr>
      <button onclick="litlegot()">Litlegot üñåÔ∏è</button>
      <p>Regras s√£o pura op√ß√£o, Eu escolho como devo pintar</p>
      <hr>
      <button onclick="abrax()">Abrax ü™∂</button>
      <p>Eu sou o √∫nico que pode Definir o Ponto final</p>
      <hr>
      <button onclick="psique()">Psique ü¶ã</button>
      <p>Entre a vida e a morte, Eu sou o Destino</p>
      <hr>
      <button onclick="yellowfer()">Yellowfer ‚è≥</button>
      <p>N√£o existe verdade Absoluta, a hist√≥ria sempre tem 2 lados</p>
      <hr>
      <button onclick="lindenbergue()">Lindenbergue ü™û</button>
      <p>Do pode ser vida?, Se o mundo √© desconhecido</p>
      <hr>
      <button onclick="beast()">Beast ‚öîÔ∏è</button>
      <p>O verdadeiro monstro, √â aquele se torna nosso aliado</p>
      <hr>
    </div>

    <div id="destransformTimer" class="timer-display"></div>

    <div id="globalChatDisplay" class="chat-display" style="display: none; margin-top: 20px;"></div>

    <div id="litlegotInterface" class="hero-interface">
      <h2>Litlegot üñåÔ∏è</h2>
      <div class="chat-input-area">
        <input type="text" id="chatInput_litlegot" placeholder="Digite sua mensagem ou comando de poder (/genesis)...">
        <button onclick="sendMessage('Litlegot', 'litlegot')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('litlegotInterface')">Sair do Chat</button>
    </div>

    <div id="abraxInterface" class="hero-interface">
      <h2>Abrax ü™∂</h2>
      <div class="chat-input-area">
        <input type="text" id="chatInput_abrax" placeholder="Digite sua mensagem ou comando de poder (/sublimacao)...">
        <button onclick="sendMessage('Abrax', 'abrax')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('abraxInterface')">Sair do Chat</button>
    </div>

    <div id="psiqueInterface" class="hero-interface">
      <h2>Psique ü¶ã</h2>
      <div class="akuma-chat-area">
        <h3>Comunica√ß√£o com Akumatizado: <span id="akumatizedNameDisplay">Ningu√©m</span></h3>
        <div class="chat-display" id="akumaChatDisplay"></div>
        <div class="chat-input-area">
          <input type="text" id="akumaChatInput" placeholder="Fale com o Akumatizado...">
          <button onclick="sendAkumaMessage('Psique')">Enviar</button>
        </div>
        <div class="akuma-control">
          <button onclick="promptAkumaName()">Akumatizar</button>
          <button onclick="desakumatizar()">Desakumatizar</button>
        </div>
      </div>
      <div class="chat-input-area">
        <input type="text" id="chatInput_psique" placeholder="Digite sua mensagem ou comando de poder (/akumatizacao)...">
        <button onclick="sendMessage('Psique', 'psique')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('psiqueInterface')">Sair do Chat</button>
    </div>

    <div id="yellowferInterface" class="hero-interface">
      <h2>Yellowfer ‚è≥</h2>
      <div class="chat-input-area">
        <input type="text" id="chatInput_yellowfer" placeholder="Digite sua mensagem ou comando de poder (/segundachance)...">
        <button onclick="sendMessage('Yellowfer', 'yellowfer')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('yellowferInterface')">Sair do Chat</button>
    </div>

    <div id="lindenbergueInterface" class="hero-interface">
      <h2>Lindenbergue ü™û</h2>
      <div class="chat-input-area">
        <input type="text" id="chatInput_lindenbergue" placeholder="Digite sua mensagem ou comando de poder (/viajar)...">
        <button onclick="sendMessage('Lindenbergue', 'lindenbergue')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('lindenbergueInterface')">Sair do Chat</button>
    </div>

    <div id="beastInterface" class="hero-interface">
      <h2>Beast ‚öîÔ∏è</h2>
      <div class="chat-input-area">
        <input type="text" id="chatInput_beast" placeholder="Digite sua mensagem ou comando de poder (/dragao)...">
        <button onclick="sendMessage('Beast', 'beast')">Enviar</button>
      </div>
      <button class="close-button" onclick="closeInterface('beastInterface')">Sair do Chat</button>
    </div>

    <div id="litlegotGenesisInterface" class="power-interface">
        <h2>G√™nesis üñåÔ∏è</h2>
        <p class="power-info">Crie qualquer objeto (tecnol√≥gico ou n√£o). Limite: n√£o pode criar magia.</p>
        <input type="text" id="genesisObjectInput" placeholder="O que deseja criar?">
        <button onclick="activateGenesis()">Criar Objeto</button>
        <p id="genesisOutput" class="power-info"></p>
        <button class="close-button" onclick="closePowerInterface('litlegotGenesisInterface')">Voltar ao Chat</button>
    </div>

    <div id="abraxSublimacaoInterface" class="power-interface">
        <h2>Sublima√ß√£o ü™∂</h2>
        <p class="power-info">Concede a si mesmo qualquer poder. Limites: n√£o pode interferir na magia de Miraculous/Kwamis, nem copiar poderes de outros Kwamis (apenas semelhantes).</p>
        <input type="text" id="sublimacaoPowerInput" placeholder="Qual poder deseja conceder a si mesmo?">
        <button onclick="activateSublimacao()">Conceder Poder</button>
        <p id="sublimacaoOutput" class="power-info"></p>
        <button class="close-button" onclick="closePowerInterface('abraxSublimacaoInterface')">Voltar ao Chat</button>
    </div>

    <div id="yellowferSecondChanceInterface" class="power-interface">
        <h2>Segunda Chance ‚è≥</h2>
        <p class="power-info">Volte 5 minutos no tempo de forma indefinida. Limites: Apenas pode voltar para o momento que ativou o poder. Se 5 minutos acabam e voc√™ n√£o volta, o efeito finaliza e destransforma.</p>
        <button onclick="activateSecondChance()">Ativar Segunda Chance</button>
        <p id="secondChanceStatus" class="power-info"></p>
        <button class="close-button" onclick="closePowerInterface('yellowferSecondChanceInterface')">Voltar ao Chat</button>
    </div>

    <div id="lindenbergueViajarInterface" class="power-interface">
        <h2>Viajar ü™û</h2>
        <p class="power-info">Abre um portal para qualquer lugar. Limite: Apenas um portal por vez.</p>
        <input type="text" id="portalDestinationInput" placeholder="Para onde deseja ir?">
        <button onclick="activateViajar()">Abrir Portal</button>
        <p id="portalStatus" class="power-info"></p>
        <button class="close-button" onclick="closePowerInterface('lindenbergueViajarInterface')">Voltar ao Chat</button>
    </div>

    <div id="beastDragaoInterface" class="power-interface">
        <h2>Drag√£o de Elemento ‚öîÔ∏è</h2>
        <p class="power-info">Controle 3 elementos. Limite: Um elemento por vez. Usar os 3 inicia o timer de 5 min para destransformar.</p>
        <p class="power-info">Elementos: Fogo, √Ågua, Vento, Terra (ex: /dragao fogo)</p>
        <input type="text" id="dragonElementInput" placeholder="Qual elemento deseja controlar? (Ex: fogo)">
        <button onclick="activateDragao()">Controlar Elemento</button>
        <p id="dragonStatus" class="power-info"></p>
        <button class="close-button" onclick="closePowerInterface('beastDragaoInterface')">Voltar ao Chat</button>
    </div>
  </div> 
  <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-analytics.js";
  import { getDatabase, ref, onValue, push, set, update, remove, get } from "https://www.gstatic.com/firebasejs/11.9.1/firebase-database.js";
    
  // Your web app's Firebase configuration
  const firebaseConfig = {
    apiKey: "AIzaSyBONdrMeMEhigQ1SEhJMrkEeArf5xfF8YA",
    authDomain: "miraculos-276b1.firebaseapp.com",
    projectId: "miraculos-276b1",
    storageBucket: "miraculos-276b1.firebasestorage.app",
    messagingSenderId: "643841644582",
    appId: "1:643841644582:web:b0eba5d722d55aea83eee7",
    measurementId: "G-FGYS755H2B"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const database = getDatabase(app);
  const analytics = getAnalytics(app);
    
  // Firebase References (updated to use ref() for v9+)
  const globalChatRef = ref(database, 'globalChatMessages');
  const powerUsedRef = ref(database, 'powerUsedState');
  const heroTransformEndTimesRef = ref(database, 'heroTransformEndTimes');
  const heroEvolvedRef = ref(database, 'heroEvolved');
  const akumaStateRef = ref(database, 'akumaState');
  const yellowferSecondChanceTimeRef = ref(database, 'yellowferSecondChanceTime');
  const yellowferSecondChanceActiveRef = ref(database, 'yellowferSecondChanceActive');
  const beastControlledElementsRef = ref(database, 'beastControlledElements');
  const chatBlockedStateRef = ref(database, 'chatBlockedState');
  const chatRedirectStateRef = ref(database, 'chatRedirectState');
  const akumatizedEffectOnChatRef = ref(database, 'akumatizedEffectOnChat');
  const litlegotCreatedItemRef = ref(database, 'litlegotCreatedItem');
  const abraxSelfGrantedPowerRef = ref(database, 'abraxSelfGrantedPower');
  const invertedChatStateRef = ref(database, 'invertedChatState');
  const akumaChatRef = ref(database, 'akumaChatMessages');
  const abraxPuppetStringsStateRef = ref(database, 'abraxPuppetStringsState');
  const psiqueGrantedPowerRef = ref(database, 'psiqueGrantedPower');
  const beastSilencedHeroesRef = ref(database, 'beastSilencedHeroes'); // New reference for Beast's silenced heroes

  // Variables for Realtime Sync (will be updated by Firebase listeners)
  let powerUsedState = {};
  let transformEndTimes = {};
  let evolvedHeroes = {};
  let akumaState = { name: "", akumaChat: [], power: "", privateChatActive: false };
  let yellowferSecondChanceActive = false;
  let yellowferSecondChanceTimestamp = null;
  let beastControlledElements = [];
  let chatBlockedState = {};
  let chatRedirectState = { active: false, fromHero: '', toHero: '', destination: '' }; // Added destination
  let akumatizedEffectOnChat = { active: false, name: '', distortedMessages: false };
  let litlegotCreatedItem = null;
  let abraxSelfGrantedPower = null;
  let invertedChatState = { active: false, targetHero: '' };
  let abraxPuppetStringsState = { active: false, targetHero: '', messagesLeft: 0 };
  let psiqueGrantedPower = { active: false, targetHero: '', grantedPowerType: '', usesRemaining: 0, granter: '' };
  let beastSilencedHeroes = []; // Array to store heroes silenced by Beast

  // Local UI state variables (not synced via Firebase)
  let destransformIntervalId = null;
  let currentActiveHero = null;
  let globalChatMessages = []; // Local cache for global messages
  let akumaChatMessages = []; // Local cache for akuma messages

  const FIVE_MINUTES_MS = 5 * 60 * 1000;
  const HERO_NAMES = ['Litlegot', 'Abrax', 'Psique', 'Yellowfer', 'Lindenbergue', 'Beast'];
  const ABRAX_PREDEFINED_POWERS = [
    'inversao', 'oraculo', 'cordas de fantoche', 'mimetismo', 'aura de cura',
    'escudo psiquico', 'projecao astral', 'teletransporte menor', 'ilusao', 'catalise'
  ];
  const PSIQUE_CONCEDE_POWERS = [
    'poder_ilimitado', 'criar_item', 'reverter_tempo', 'silenciar_beast' // Renamed 'silenciar' to avoid conflict and specify target
  ];


  // --- Firebase Data Listeners ---
  function setupFirebaseListeners() {
    onValue(globalChatRef, (snapshot) => {
      // Firebase stores lists as objects with unique keys, convert to array for easier processing
      globalChatMessages = [];
      snapshot.forEach((childSnapshot) => {
        globalChatMessages.push({ key: childSnapshot.key, ...childSnapshot.val() });
      });
      renderGlobalChat();
    });

    onValue(akumaChatRef, (snapshot) => {
      akumaChatMessages = [];
      snapshot.forEach((childSnapshot) => {
        akumaChatMessages.push({ key: childSnapshot.key, ...childSnapshot.val() });
      });
      renderAkumaChat();
    });

    onValue(powerUsedRef, (snapshot) => {
      powerUsedState = snapshot.val() || {};
    });

    onValue(heroTransformEndTimesRef, (snapshot) => {
      transformEndTimes = snapshot.val() || {};
      if (currentActiveHero && transformEndTimes[currentActiveHero] && !evolvedHeroes[currentActiveHero]) {
        updateDestransformTimerDisplay(currentActiveHero, transformEndTimes[currentActiveHero]);
      } else if (currentActiveHero && evolvedHeroes[currentActiveHero]) {
        hideDestransformTimer();
      }
    });

    onValue(heroEvolvedRef, (snapshot) => {
      evolvedHeroes = snapshot.val() || {};
      if (currentActiveHero && evolvedHeroes[currentActiveHero]) {
        hideDestransformTimer();
        if (transformTimers[currentActiveHero]) {
          clearTimeout(transformTimers[currentActiveHero]);
          delete transformTimers[currentActiveHero];
          remove(ref(database, `heroTransformEndTimes/${currentActiveHero}`));
        }
      }
    });

    onValue(akumaStateRef, (snapshot) => {
      akumaState = snapshot.val() || { name: "", akumaChat: [], power: "", privateChatActive: false };
      updateAkumaDisplay();
      const akumaChatArea = document.querySelector('.akuma-chat-area');
      if (akumaState.name && akumaState.privateChatActive && akumaChatArea) {
        akumaChatArea.classList.add('akumatized-chat-effect');
      } else if (akumaChatArea) {
        akumaChatArea.classList.remove('akumatized-chat-effect');
      }
    });

    onValue(yellowferSecondChanceTimeRef, (snapshot) => {
      yellowferSecondChanceTimestamp = snapshot.val();
      if (yellowferSecondChanceTimestamp) {
        document.getElementById('secondChanceStatus').innerText = `Segunda Chance Ativada! Ponto de retorno: ${new Date(yellowferSecondChanceTimestamp).toLocaleTimeString()}`;
      } else {
        document.getElementById('secondChanceStatus').innerText = '';
      }
    });

    onValue(yellowferSecondChanceActiveRef, (snapshot) => {
      yellowferSecondChanceActive = snapshot.val() || false;
    });

    onValue(beastControlledElementsRef, (snapshot) => {
      beastControlledElements = snapshot.val() || [];
    });

    onValue(chatBlockedStateRef, (snapshot) => {
      chatBlockedState = snapshot.val() || {};
      renderGlobalChat();
    });

    onValue(chatRedirectStateRef, (snapshot) => {
      chatRedirectState = snapshot.val() || { active: false, fromHero: '', toHero: '', destination: '' };
    });

    onValue(akumatizedEffectOnChatRef, (snapshot) => {
      akumatizedEffectOnChat = snapshot.val() || { active: false, name: '', distortedMessages: false };
      renderGlobalChat();
    });

    onValue(litlegotCreatedItemRef, (snapshot) => {
      litlegotCreatedItem = snapshot.val();
      const genesisOutput = document.getElementById('genesisOutput');
      if (genesisOutput) {
        genesisOutput.innerText = litlegotCreatedItem ? `Item criado: "${litlegotCreatedItem}"` : '';
      }
    });

    onValue(abraxSelfGrantedPowerRef, (snapshot) => {
      abraxSelfGrantedPower = snapshot.val();
      const sublimacaoOutput = document.getElementById('sublimacaoOutput');
      if (sublimacaoOutput) {
        sublimacaoOutput.innerText = abraxSelfGrantedPower ? `Poder concedido: "${abraxSelfGrantedPower}"` : '';
      }
    });

    onValue(invertedChatStateRef, (snapshot) => {
      invertedChatState = snapshot.val() || { active: false, targetHero: '' };
      renderGlobalChat();
    });

    onValue(abraxPuppetStringsStateRef, (snapshot) => {
      abraxPuppetStringsState = snapshot.val() || { active: false, targetHero: '', messagesLeft: 0 };
    });

    onValue(psiqueGrantedPowerRef, (snapshot) => {
      psiqueGrantedPower = snapshot.val() || { active: false, targetHero: '', grantedPowerType: '', usesRemaining: 0, granter: '' };
    });

    onValue(beastSilencedHeroesRef, (snapshot) => {
        beastSilencedHeroes = snapshot.val() || [];
    });
  }

  // Call listeners on load
  setupFirebaseListeners();

  // Load last active hero state from localStorage if available
  document.addEventListener('DOMContentLoaded', () => {
    const lastActiveHeroOnLoad = localStorage.getItem('lastActiveHero');
    const storedEndTimes = JSON.parse(localStorage.getItem('heroTransformEndTimes') || '{}'); // Retrieve stored end times
    
    // Only activate if there's a last active hero and no power_ilimitado
    if (
      lastActiveHeroOnLoad &&
      storedEndTimes[lastActiveHeroOnLoad] &&
      !(psiqueGrantedPower.active && psiqueGrantedPower.targetHero === lastActiveHeroOnLoad && psiqueGrantedPower.grantedPowerType === 'poder_ilimitado')
    ) {
      currentActiveHero = lastActiveHeroOnLoad;
      // Re-initialize the timer display based on stored end time
      updateDestransformTimerDisplay(lastActiveHeroOnLoad, storedEndTimes[lastActiveHeroOnLoad]);
      // Show the interface if a hero was active, otherwise hide the timer
      const lastInterfaceId = `${lastActiveHeroOnLoad.toLowerCase()}Interface`;
      const interfaceElement = document.getElementById(lastInterfaceId);
      if (interfaceElement) {
        document.querySelectorAll('.hero-interface, .power-interface').forEach(el => el.style.display = 'none');
        document.getElementById('heroButtons').style.display = 'none';
        interfaceElement.style.display = 'flex';
      } else {
        hideDestransformTimer();
        document.getElementById('heroButtons').style.display = 'block';
      }
    } else {
      // If no active hero or unlimited power, ensure buttons are visible and timer is hidden
      document.getElementById('heroButtons').style.display = 'block';
      hideDestransformTimer();
    }
    renderGlobalChat();
    updateAkumaDisplay();
    renderAkumaChat();
  });

  // --- Hero transformation functions ---
  function litlegot() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'inspira√ß√£o') {
      alert("Ziggy! Inspira√ß√£o!");
      showInterface('litlegotInterface', 'Litlegot');
    } else if (transforma !== null) {
      alert("Diga a Ziggy Sua frase De transforma√ß√£o");
    } else {
      alert('Ordem Nula!');
    }
  }

  function abrax() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'sol nascente') {
      alert("Orikko! Sol Nascente!");
      showInterface('abraxInterface', 'Abrax');
    } else if (transforma !== null) {
      alert("Diga ao Orikko Sua frase de transforma√ß√£o!");
    } else {
      alert('Ordem Nula!');
    }
  }

  function psique() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'irradia√ß√£o') {
      alert("Nooroo! Irradiar!");
      showInterface('psiqueInterface', 'Psique');
    } else if (transforma !== null) {
      alert("Diga ao Nooroo Sua frase de transforma√ß√£o!");
    } else {
      alert('Ordem Nula!');
    }
  }

  function yellowfer() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'restaurar') {
      alert("Sazz! Restaura√ß√£o!");
      showInterface('yellowferInterface', 'Yellowfer');
    } else if (transforma !== null) {
      alert("Diga ao Sazz Sua frase de transforma√ß√£o!");
    } else {
      alert('Ordem Nula!');
    }
  }

  function lindenbergue() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'viajar') { // Corrected phrase
      alert("Kaalki! Viajar!");
      showInterface('lindenbergueInterface', 'Lindenbergue');
    } else if (transforma !== null) {
      alert("Diga ao Kaalki Sua frase de transforma√ß√£o!");
    } else {
      alert('Ordem Nula!');
    }
  }

  function beast() {
    const transforma = prompt("Frase de transforma√ß√£o:");
    if (transforma && transforma.toLowerCase() === 'rugido') {
      alert("Stompp! Rugido!");
      showInterface('beastInterface', 'Beast');
    } else if (transforma !== null) {
      alert("Diga ao Stompp Sua frase de transforma√ß√£o!");
    } else {
      alert('Ordem Nula!');
    }
  }

  // --- Interface Control Functions ---
  function showInterface(interfaceId, heroName) {
    document.querySelectorAll('.hero-interface, .power-interface').forEach(el => el.style.display = 'none');
    document.getElementById('heroButtons').style.display = 'none';
    document.getElementById('globalChatDisplay').style.display = 'block';

    const interfaceElement = document.getElementById(interfaceId);
    if (interfaceElement) {
      interfaceElement.style.display = 'flex';
      currentActiveHero = heroName;
      localStorage.setItem('lastActiveHero', heroName);

      // Start transformation timer if not already evolved or unlimited power
      if (!evolvedHeroes[heroName] && !(psiqueGrantedPower.active && psiqueGrantedPower.targetHero === heroName && psiqueGrantedPower.grantedPowerType === 'poder_ilimitado')) {
          startTransformTimer(heroName);
      } else if (evolvedHeroes[heroName]) {
          hideDestransformTimer(); // Hide if already evolved
      }
      
      // Focus on the chat input
      const chatInputId = `chatInput_${heroName.toLowerCase()}`;
      const chatInput = document.getElementById(chatInputId);
      if (chatInput) {
          chatInput.focus();
      }
    }
  }

  function closeInterface(interfaceId) {
    document.getElementById(interfaceId).style.display = 'none';
    document.getElementById('heroButtons').style.display = 'block';
    document.getElementById('globalChatDisplay').style.display = 'none';
    
    // Reset hero state on close
    if (currentActiveHero) {
      resetHeroState(currentActiveHero);
    }
    currentActiveHero = null;
    localStorage.removeItem('lastActiveHero');
    hideDestransformTimer(); // Ensure timer is hidden on interface close
  }

  function showPowerInterface(powerInterfaceId) {
    document.querySelectorAll('.hero-interface').forEach(el => el.style.display = 'none');
    document.getElementById(powerInterfaceId).style.display = 'flex';
  }

  function closePowerInterface(powerInterfaceId) {
    document.getElementById(powerInterfaceId).style.display = 'none';
    // Re-show the hero's main chat interface
    if (currentActiveHero) {
        showInterface(`${currentActiveHero.toLowerCase()}Interface`, currentActiveHero);
    } else {
        document.getElementById('heroButtons').style.display = 'block';
    }
  }

  // --- Chat and Power Logic ---
  // Helper to get chat input element
  function getChatInput(heroId) {
    if (heroId === 'akuma') {
        return document.getElementById('akumaChatInput');
    }
    return document.getElementById(`chatInput_${heroId}`);
  }

  // Common function to send messages
  window.sendMessage = async function(senderName, inputId) {
    const chatInput = getChatInput(inputId);
    const messageText = chatInput.value.trim();
    if (!messageText) return;

    // Check if sender is blocked
    if (chatBlockedState[senderName]) {
        alert(`${senderName}, seu chat est√° bloqueado!`);
        chatInput.value = '';
        return;
    }
    
    let actualSender = senderName;
    let messageContent = messageText;
    let messageClasses = [];
    let isCommand = false;

    // --- Command Handling ---
    if (messageText.startsWith('/')) {
      isCommand = true;
      const commandParts = messageText.substring(1).split(' ');
      const command = commandParts[0].toLowerCase();
      const arg = commandParts.slice(1).join(' ');

      const isPowerUsed = powerUsedState[senderName];
      const isEvolved = evolvedHeroes[senderName];
      const hasUnlimitedPower = (psiqueGrantedPower.active && psiqueGrantedPower.targetHero === senderName && psiqueGrantedPower.grantedPowerType === 'poder_ilimitado');

      // Commands that are NOT powers but start with /
      if (senderName === 'Abrax' && command === 'ativar_poder') {
        if (!arg) {
          alert('Por favor, especifique o poder que Abrax deseja ativar.');
          chatInput.value = '';
          return;
        }
        if (!ABRAX_PREDEFINED_POWERS.includes(arg.toLowerCase())) {
          alert(`"${arg}" n√£o √© um poder pr√©-definido para Abrax. Escolha entre: ${ABRAX_PREDEFINED_POWERS.join(', ')}.`);
          chatInput.value = '';
          return;
        }
        await set(abraxSelfGrantedPowerRef, arg);
        await push(globalChatRef, { sender: senderName, message: `Abrax concedeu a si mesmo o poder de "${arg}"!`, timestamp: Date.now(), isSystem: true });
        chatInput.value = '';
        return;
      }
      if (senderName === 'Psique' && command === 'conceder_poder') {
        const [targetHero, powerType, uses] = commandParts.slice(1);
        if (!targetHero || !powerType || !uses || isNaN(parseInt(uses))) {
            alert('Uso: /conceder_poder [Nome do Her√≥i] [Tipo de Poder] [Usos (n√∫mero)]');
            chatInput.value = '';
            return;
        }
        if (!HERO_NAMES.includes(targetHero) || !PSIQUE_CONCEDE_POWERS.includes(powerType.toLowerCase())) {
            alert(`Her√≥i ou tipo de poder inv√°lido. Her√≥is: ${HERO_NAMES.join(', ')}. Poderes: ${PSIQUE_CONCEDE_POWERS.join(', ')}`);
            chatInput.value = '';
            return;
        }
        await set(psiqueGrantedPowerRef, {
            active: true,
            targetHero: targetHero,
            grantedPowerType: powerType.toLowerCase(),
            usesRemaining: parseInt(uses),
            granter: senderName
        });
        await push(globalChatRef, { sender: senderName, message: `Psique concedeu o poder "${powerType}" para ${targetHero} com ${uses} usos!`, timestamp: Date.now(), isSystem: true });
        chatInput.value = '';
        return;
      }

      // Check if main power is already used (5-minute timer) or if not evolved
      if (isPowerUsed && !isEvolved && !hasUnlimitedPower) {
        alert(`${senderName}, seu poder principal j√° foi usado e voc√™ est√° no tempo de destransforma√ß√£o!`);
        chatInput.value = '';
        return;
      }

      switch (senderName) {
        case 'Litlegot':
          if (command === 'genesis') {
            showPowerInterface('litlegotGenesisInterface');
            await set(ref(database, powerUsedRef.key + '/' + senderName), true);
          } else {
            alert('Comando desconhecido ou poder j√° usado!');
          }
          break;
        case 'Abrax':
          if (command === 'sublimacao') {
            showPowerInterface('abraxSublimacaoInterface');
            await set(ref(database, powerUsedRef.key + '/' + senderName), true);
          } else if (command === 'inversao') {
            const targetHero = arg.charAt(0).toUpperCase() + arg.slice(1).toLowerCase();
            if (HERO_NAMES.includes(targetHero)) {
                await set(invertedChatStateRef, { active: true, targetHero: targetHero });
                await push(globalChatRef, { sender: senderName, message: `Abrax inverteu o chat de ${targetHero}!`, timestamp: Date.now(), isSystem: true });
                await set(ref(database, powerUsedRef.key + '/' + senderName), true); // Considers a power use
            } else {
                alert('Her√≥i alvo inv√°lido para invers√£o.');
            }
          } else if (command === 'cordas_de_fantoche') { // Added Puppet Strings
            const [targetHero, messagesNum] = arg.split(' ');
            const numMessages = parseInt(messagesNum);
            const formattedTargetHero = targetHero.charAt(0).toUpperCase() + targetHero.slice(1).toLowerCase();

            if (HERO_NAMES.includes(formattedTargetHero) && !isNaN(numMessages) && numMessages > 0) {
                await set(abraxPuppetStringsStateRef, { active: true, targetHero: formattedTargetHero, messagesLeft: numMessages });
                await push(globalChatRef, { sender: senderName, message: `Abrax agora controla as mensagens de ${formattedTargetHero} por ${numMessages} mensagens!`, timestamp: Date.now(), isSystem: true });
                await set(ref(database, powerUsedRef.key + '/' + senderName), true); // Considers a power use
            } else {
                alert('Uso: /cordas_de_fantoche [Nome do Her√≥i] [N√∫mero de Mensagens]');
            }
          } else {
            alert('Comando desconhecido ou poder j√° usado!');
          }
          break;
        case 'Psique':
          if (command === 'akumatizacao') {
            showPowerInterface('psiqueInterface'); // Psique's main interface is also her power interface
            // The promptAkumaName and desakumatizar handle the powerUsedState for Psique
          } else {
            alert('Comando desconhecido ou poder j√° usado!');
          }
          break;
        case 'Yellowfer':
          if (command === 'segundachance') {
            showPowerInterface('yellowferSecondChanceInterface');
            await set(ref(database, powerUsedRef.key + '/' + senderName), true);
          } else {
            alert('Comando desconhecido ou poder j√° usado!');
          }
          break;
        case 'Lindenbergue':
            if (command === 'viajar') {
                showPowerInterface('lindenbergueViajarInterface');
                await set(ref(database, powerUsedRef.key + '/' + senderName), true);
            } else {
                alert('Comando desconhecido ou poder j√° usado!');
            }
            break;
        case 'Beast':
            if (command === 'dragao') {
                showPowerInterface('beastDragaoInterface');
                // Power used state for Beast's main power is handled when 3 elements are controlled
            } else if (command === 'silenciar') {
                const targetHero = arg.charAt(0).toUpperCase() + arg.slice(1).toLowerCase();
                if (HERO_NAMES.includes(targetHero) && targetHero !== senderName) {
                    await activareBeastSilence(targetHero, senderName);
                } else {
                    alert('Her√≥i alvo inv√°lido para silenciar ou voc√™ n√£o pode silenciar a si mesmo.');
                }
            } else {
                alert('Comando desconhecido ou poder j√° usado!');
            }
            break;
        default:
          alert('Comando de poder n√£o reconhecido para este her√≥i.');
          break;
      }
      chatInput.value = '';
      return; // Command handled, exit function
    }

    // --- Message Processing (not commands) ---

    // Abrax Puppet Strings effect
    if (abraxPuppetStringsState.active && abraxPuppetStringsState.targetHero === senderName) {
        if (abraxPuppetStringsState.messagesLeft > 0) {
            messageContent = `(Controlado por Abrax) ${messageText}`;
            await set(ref(database, abraxPuppetStringsStateRef.key + '/messagesLeft'), abraxPuppetStringsState.messagesLeft - 1);
        } else {
            await set(abraxPuppetStringsStateRef, { active: false, targetHero: '', messagesLeft: 0 });
            await push(globalChatRef, { sender: 'Sistema', message: `O controle de Abrax sobre ${senderName} terminou.`, timestamp: Date.now(), isSystem: true });
        }
    }

    // Chat Redirection (Lindenbergue)
    if (chatRedirectState.active && chatRedirectState.fromHero === senderName) {
        // Messages from the 'fromHero' are now directed 'toHero'
        // We'll indicate it's via Lindenberg's portal
        const originalSender = senderName;
        actualSender = chatRedirectState.toHero; // This is the ' ÿ∏ÿßŸáÿ± ' sender in chat
        messageContent = `(Via Portal de Lindenbergue para ${chatRedirectState.destination}) ${originalSender}: ${messageText}`;
        messageClasses.push('lindenbergue-portal-message'); // Add a class for styling if needed
    }
    
    // Akumatized message distortion (Psique)
    if (akumatizedEffectOnChat.active && akumatizedEffectOnChat.name === senderName && akumatizedEffectOnChat.distortedMessages) {
        // Simple distortion: reverse text
        messageContent = messageContent.split('').reverse().join('');
        messageClasses.push('akumatized-message-style');
    }
    
    const newMessage = {
      sender: actualSender,
      message: messageContent,
      timestamp: Date.now(),
      classes: messageClasses.length > 0 ? messageClasses : null,
      originalSender: senderName === actualSender ? null : senderName, // Track original sender for redirection
      viaPortalDestination: chatRedirectState.active && chatRedirectState.fromHero === senderName ? chatRedirectState.destination : null
    };

    await push(globalChatRef, newMessage);
    chatInput.value = '';
  };

  // Function to render messages in the global chat display
  function renderGlobalChat() {
    const chatDisplay = document.getElementById('globalChatDisplay');
    chatDisplay.innerHTML = ''; // Clear previous messages

    globalChatMessages.forEach(msg => {
      const messageElement = document.createElement('p');
      messageElement.classList.add('chat-message');

      if (msg.isSystem) {
        messageElement.innerHTML = `<strong>Sistema:</strong> ${msg.message}`;
        messageElement.style.color = '#FFD700'; // Gold for system messages
      } else {
        let senderToDisplay = msg.sender;
        let messageText = msg.message;
        let messageClasses = msg.classes || [];

        // Apply Abrax inversion effect if active for this message's sender
        if (invertedChatState.active && invertedChatState.targetHero === msg.sender) {
            messageClasses.push('abrax-inverted-chat-effect');
        }

        // Apply Akuma distortion style if active for this message's sender
        if (akumatizedEffectOnChat.active && akumatizedEffectOnChat.name === msg.sender && akumatizedEffectOnChat.distortedMessages) {
            // Already reversed the text in sendMessage, just apply style here
            messageClasses.push('akumatized-message-style');
        }

        // Handle Lindenbergue portal display
        if (msg.viaPortalDestination) {
            senderToDisplay = `${msg.originalSender} (via Portal de Lindenbergue para ${msg.viaPortalDestination})`;
        }
        
        messageElement.innerHTML = `<strong>${senderToDisplay}:</strong> ${messageText}`;
        messageClasses.forEach(cls => messageElement.classList.add(cls));
      }

      chatDisplay.appendChild(messageElement);
    });
    // Scroll to the bottom
    chatDisplay.scrollTop = chatDisplay.scrollHeight;
  }

  // Event listener for Enter key in all chat inputs
  document.addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
      const activeElement = document.activeElement;
      if (activeElement && activeElement.id.startsWith('chatInput_')) {
        const heroName = activeElement.id.replace('chatInput_', '').replace('akumaChatInput', 'akuma');
        sendMessage(heroName.charAt(0).toUpperCase() + heroName.slice(1), heroName);
      } else if (activeElement && activeElement.id === 'akumaChatInput') {
        sendAkumaMessage('Psique');
      }
    }
  });

  // --- Destransformation Timer ---
  const transformTimers = {}; // To store setTimeout IDs for each hero

  async function startTransformTimer(heroName) {
    // Clear any existing timer for this hero
    if (transformTimers[heroName]) {
      clearTimeout(transformTimers[heroName]);
    }

    const endTime = Date.now() + FIVE_MINUTES_MS;
    await set(ref(database, `heroTransformEndTimes/${heroName}`), endTime);
    
    updateDestransformTimerDisplay(heroName, endTime);

    transformTimers[heroName] = setTimeout(async () => {
      if (!evolvedHeroes[heroName]) { // Only destransform if not evolved
        await destransformHero(heroName);
      }
    }, FIVE_MINUTES_MS);
  }

  function updateDestransformTimerDisplay(heroName, endTime) {
    const timerDisplay = document.getElementById('destransformTimer');
    timerDisplay.style.display = 'block';

    if (destransformIntervalId) {
      clearInterval(destransformIntervalId);
    }

    destransformIntervalId = setInterval(() => {
      const now = Date.now();
      const timeLeft = endTime - now;

      if (timeLeft <= 0) {
        clearInterval(destransformIntervalId);
        timerDisplay.style.display = 'none';
        // destransformHero will be called by the setTimeout in startTransformTimer
        return;
      }

      const minutes = Math.floor(timeLeft / (60 * 1000));
      const seconds = Math.floor((timeLeft % (60 * 1000)) / 1000);
      timerDisplay.innerText = `Destransforma√ß√£o de ${heroName} em: ${minutes}m ${seconds}s`;
    }, 1000);
  }

  function hideDestransformTimer() {
    const timerDisplay = document.getElementById('destransformTimer');
    timerDisplay.style.display = 'none';
    if (destransformIntervalId) {
      clearInterval(destransformIntervalId);
      destransformIntervalId = null;
    }
  }

  async function destransformHero(heroName) {
    alert(`${heroName} se destransformou!`);
    await resetHeroState(heroName);
    hideDestransformTimer();
    // Close the current interface if it belongs to the destransformed hero
    const interfaceId = `${heroName.toLowerCase()}Interface`;
    if (document.getElementById(interfaceId).style.display === 'flex') {
        closeInterface(interfaceId);
    }
  }

  async function resetHeroState(heroName) {
    console.log(`Resetting state for ${heroName}`);
    // Reset specific power used state for the hero
    await remove(ref(database, powerUsedRef.key + '/' + heroName));
    
    // Clear the transformation end time for this hero
    await remove(ref(database, `heroTransformEndTimes/${heroName}`));
    
    // Also clear from local storage
    const storedEndTimes = JSON.parse(localStorage.getItem('heroTransformEndTimes') || '{}');
    delete storedEndTimes[heroName];
    localStorage.setItem('heroTransformEndTimes', JSON.stringify(storedEndTimes));

    // Clear hero-specific states and effects
    switch (heroName) {
        case 'Litlegot':
            await set(litlegotCreatedItemRef, null);
            break;
        case 'Abrax':
            await set(abraxSelfGrantedPowerRef, null);
            await set(invertedChatStateRef, { active: false, targetHero: '' });
            await set(abraxPuppetStringsStateRef, { active: false, targetHero: '', messagesLeft: 0 });
            break;
        case 'Psique':
            await set(akumaStateRef, { name: "", akumaChat: [], power: "", privateChatActive: false }); // Ensure akumaState is fully reset
            await set(akumatizedEffectOnChatRef, { active: false, name: '', distortedMessages: false });
            await set(akumaChatRef, {}); // Clear akuma chat messages
            // Also ensure the previously akumatized hero is unblocked
            if (akumaState.name) {
                await set(ref(database, `chatBlockedState/${akumaState.name}`), false);
            }
            break;
        case 'Yellowfer':
            await set(yellowferSecondChanceTimeRef, null);
            await set(yellowferSecondChanceActiveRef, false);
            break;
        case 'Lindenbergue':
            await set(chatRedirectStateRef, { active: false, fromHero: '', toHero: '', destination: '' });
            break;
        case 'Beast':
            await set(beastControlledElementsRef, []);
            // Unblock all heroes Beast had silenced
            if (beastSilencedHeroes && beastSilencedHeroes.length > 0) {
                for (const hero of beastSilencedHeroes) {
                    await set(ref(database, `chatBlockedState/${hero}`), false);
                }
                await set(beastSilencedHeroesRef, []); // Clear Beast's silenced heroes list
            }
            break;
    }
  }

  // --- Akuma Mode Functions ---
  async function sendAkumaMessage(senderHero) {
    const chatInput = document.getElementById('akumaChatInput');
    const messageText = chatInput.value.trim();
    if (!messageText || !akumaState.name) return;

    const newMessage = {
      sender: senderHero,
      message: messageText,
      timestamp: Date.now()
    };
    await push(akumaChatRef, newMessage);
    chatInput.value = '';
  }

  async function promptAkumaName() {
    const name = prompt("Qual nome do civil que voc√™ deseja akumatizar?");
    if (name) {
      const power = prompt(`Qual poder voc√™ deseja dar ao Akumatizado ${name}?`);
      if (power) {
        await set(akumaStateRef, { name: name, akumaChat: [], power: power, privateChatActive: true });
        await set(akumatizedEffectOnChatRef, { active: true, name: name, distortedMessages: true }); // Activate distortion
        await set(ref(database, `chatBlockedState/${name}`), true); // Block akumatized hero's global chat
        await push(globalChatRef, { sender: 'Psique', message: `Psique akumatizou ${name} com o poder de ${power}!`, timestamp: Date.now(), isSystem: true });
        // Set Psique's powerUsedState to true for 5 min timer
        await set(ref(database, powerUsedRef.key + '/Psique'), true);
      } else {
        alert('Poder do Akumatizado n√£o pode ser vazio.');
      }
    } else {
      alert('Nome do Akumatizado n√£o pode ser vazio.');
    }
  }

  async function desakumatizar() {
    if (akumaState.name) {
      await push(globalChatRef, { sender: 'Psique', message: `${akumaState.name} foi desakumatizado!`, timestamp: Date.now(), isSystem: true });
      await set(akumaStateRef, { name: "", akumaChat: [], power: "", privateChatActive: false });
      await set(akumatizedEffectOnChatRef, { active: false, name: '', distortedMessages: false }); // Clear distortion
      await set(akumaChatRef, {}); // Clear akuma chat messages
      await set(ref(database, `chatBlockedState/${akumaState.name}`), false); // Unblock akumatized hero's global chat
      // Reset Psique's powerUsedState
      await remove(ref(database, powerUsedRef.key + '/Psique'));
      alert(`${akumaState.name} foi desakumatizado!`);
    } else {
      alert("Ningu√©m est√° akumatizado no momento.");
    }
  }

  function updateAkumaDisplay() {
    document.getElementById('akumatizedNameDisplay').innerText = akumaState.name || "Ningu√©m";
  }

  function renderAkumaChat() {
    const chatDisplay = document.getElementById('akumaChatDisplay');
    chatDisplay.innerHTML = '';
    akumaChatMessages.forEach(msg => {
      const messageElement = document.createElement('p');
      messageElement.classList.add('chat-message');
      messageElement.innerHTML = `<strong>${msg.sender}:</strong> ${msg.message}`;
      chatDisplay.appendChild(messageElement);
    });
    chatDisplay.scrollTop = chatDisplay.scrollHeight;
  }

  // --- Power Activation Functions ---
  window.activateGenesis = async function() { // Poder do Litlegot
    const objectName = document.getElementById('genesisObjectInput').value.trim();
    if (objectName) {
      await set(litlegotCreatedItemRef, objectName);
      await push(globalChatRef, { sender: 'Litlegot', message: `Litlegot criou o objeto: "${objectName}"!`, timestamp: Date.now(), isSystem: true });
      alert(`Litlegot criou: ${objectName}`);
      closePowerInterface('litlegotGenesisInterface');
    } else {
      alert('Por favor, insira o nome do objeto a ser criado.');
    }
  }

  window.activateSublimacao = async function() { // Poder do Abrax
    const powerName = document.getElementById('sublimacaoPowerInput').value.trim();
    if (powerName) {
      await set(abraxSelfGrantedPowerRef, powerName);
      await push(globalChatRef, { sender: 'Abrax', message: `Abrax concedeu a si mesmo o poder de "${powerName}"!`, timestamp: Date.now(), isSystem: true });
      alert(`Abrax agora tem o poder de: ${powerName}`);
      closePowerInterface('abraxSublimacaoInterface');
    } else {
      alert('Por favor, insira o poder a ser concedido.');
    }
  }

  window.activateSecondChance = async function() { // Poder do Yellowfer
    if (!yellowferSecondChanceActive) {
      // Activate Second Chance - set the timestamp for return
      await set(yellowferSecondChanceTimeRef, Date.now());
      await set(yellowferSecondChanceActiveRef, true);
      await push(globalChatRef, { sender: 'Yellowfer', message: `Yellowfer ativou Segunda Chance! O tempo pode ser revertido.`, timestamp: Date.now(), isSystem: true });
      document.getElementById('secondChanceStatus').innerText = `Segunda Chance Ativada! Ponto de retorno: ${new Date().toLocaleTimeString()}`;
      alert('Segunda Chance Ativada! Voc√™ pode retornar a este momento.');
    } else {
      // Return in time
      if (yellowferSecondChanceTimestamp) {
        // Here, we effectively "reset" the current state to the timestamp.
        // For transformation timer, this means restarting it from the "return" point.
        await push(globalChatRef, { sender: 'Yellowfer', message: `Yellowfer reverteu o tempo para o ponto de Segunda Chance!`, timestamp: Date.now(), isSystem: true });
        
        // Reset Yellowfer's main transformation timer
        startTransformTimer('Yellowfer'); // Restart the 5-minute timer from now

        await set(yellowferSecondChanceTimeRef, null);
        await set(yellowferSecondChanceActiveRef, false);
        document.getElementById('secondChanceStatus').innerText = '';
        alert('Tempo revertido!');
        closePowerInterface('yellowferSecondChanceInterface');
      } else {
        alert('Ponto de retorno da Segunda Chance n√£o encontrado.');
      }
    }
  }

  window.activateViajar = async function() { // Poder do Lindenbergue
    const destination = document.getElementById('portalDestinationInput').value.trim();
    if (destination) {
      await push(globalChatRef, { sender: 'Lindenbergue', message: `Lindenbergue abriu um portal para: ${destination}!`, timestamp: Date.now(), isSystem: true });
      alert(`Portal aberto para: ${destination}`);
      
      // Optional: Ask to redirect chat through the portal
      const redirectTarget = prompt(`Deseja redirecionar o chat de qual her√≥i para ${destination}? (Digite o nome do her√≥i, ou deixe em branco)`);
      if (redirectTarget && HERO_NAMES.includes(redirectTarget)) {
          await set(chatRedirectStateRef, { active: true, fromHero: redirectTarget, toHero: 'Lindenbergue', destination: destination }); // Store destination
          await push(globalChatRef, { sender: 'Sistema', message: `O chat de ${redirectTarget} agora est√° sendo redirecionado por Lindenbergue para ${destination}.`, timestamp: Date.now(), isSystem: true });
      } else if (redirectTarget) {
          alert('Her√≥i alvo para redirecionamento inv√°lido.');
      }

      closePowerInterface('lindenbergueViajarInterface');
    } else {
      alert('Por favor, insira o destino do portal.');
    }
  }

  // Beast's elements and silencing
  let currentElementsCount = 0; // Local counter for elements controlled
  window.activateDragao = async function() { // Poder do Beast
    const element = document.getElementById('dragonElementInput').value.trim().toLowerCase();
    const validElements = ['fogo', 'agua', 'vento', 'terra'];

    if (!element || !validElements.includes(element)) {
      alert('Por favor, insira um elemento v√°lido (fogo, agua, vento, terra).');
      return;
    }

    if (beastControlledElements.includes(element)) {
      alert(`Beast j√° controla o elemento ${element}. Escolha outro.`);
      return;
    }

    if (currentElementsCount < 3) {
      const newElements = [...beastControlledElements, element];
      await set(beastControlledElementsRef, newElements);
      await push(globalChatRef, { sender: 'Beast', message: `Beast agora controla o elemento: ${element}!`, timestamp: Date.now(), isSystem: true });
      document.getElementById('dragonStatus').innerText = `Elemento controlado: ${element}`;
      alert(`Beast agora controla: ${element}`);
      
      currentElementsCount++; // Increment local counter

      // Prompt to silence a hero with each element
      const heroToSilence = prompt(`Com o poder de ${element}, qual her√≥i Beast deseja silenciar?`);
      if (heroToSilence && HERO_NAMES.includes(heroToSilence) && heroToSilence !== 'Beast') {
          // Check if this hero is already silenced by Beast in this transformation
          if (!beastSilencedHeroes.includes(heroToSilence)) {
              await activareBeastSilence(heroToSilence, 'Beast');
              // Add to locally tracked silenced heroes for this transformation
              await set(beastSilencedHeroesRef, [...beastSilencedHeroes, heroToSilence]);
          } else {
              alert(`${heroToSilence} j√° foi silenciado por Beast nesta transforma√ß√£o.`);
          }
      } else if (heroToSilence) {
          alert('Nome do her√≥i para silenciar √© inv√°lido ou voc√™ n√£o pode silenciar a si mesmo.');
      }
    }

    if (currentElementsCount === 3) {
      await set(ref(database, powerUsedRef.key + '/Beast'), true); // Set Beast's powerUsedState to true after controlling 3 elements
      alert("Beast controlou 3 elementos! O timer de destransforma√ß√£o de 5 minutos foi ativado!");
      closePowerInterface('beastDragaoInterface'); // Close interface after all elements are controlled
    }
  }

  window.activareBeastSilence = async function(targetHero, silencerName) {
    if (HERO_NAMES.includes(targetHero)) {
        await set(ref(database, `chatBlockedState/${targetHero}`), true);
        await push(globalChatRef, { sender: silencerName, message: `O chat de ${targetHero} foi silenciado por ${silencerName}!`, timestamp: Date.now(), isSystem: true });
        alert(`${targetHero} foi silenciado!`);
    } else {
        alert('Her√≥i alvo inv√°lido para silenciar.');
    }
  }

  // --- General Utility Functions ---
  window.sendMessage = sendMessage;
  window.closeInterface = closeInterface;
  window.showPowerInterface = showPowerInterface;
  window.closePowerInterface = closePowerInterface;

  // --- Akuma Mode Functions (window scope for onclick) ---
  window.sendAkumaMessage = sendAkumaMessage;
  window.promptAkumaName = promptAkumaName;
  window.desakumatizar = desakumatizar;
</script>
</body>
</html>
